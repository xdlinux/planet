<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/cover.png" alt="Featured image of post 屏幕 控制 电机(pid)" /><h1 id="保命事项">保命事项</h1>
<ol>
<li>VCC等电压和GND接地千万不要接反! 否则板子升天, money打水漂.</li>
</ol>
<h2 id="元器件列表">元器件列表</h2>
<p>感谢物院实验室某佬倾情相借!</p>
<ol>
<li>Stm32 H750VBT6</li>
<li>轮趣科技 Tb6612 稳压版电机驱动</li>
<li>轮趣科技 MG513 霍尔解码器版电机</li>
<li>TJC3224K024 触控屏</li>
<li>PWlink2 lite版本 下载\调试器</li>
<li>一块电池</li>
</ol>
<h2 id="使用工具">使用工具</h2>
<ol>
<li>Vscode ＋ EIDE套装</li>
<li>Keil u5(</li>
<li>Stm Cube MX</li>
<li>USART HMI (TJC图形化编程工具)</li>
</ol>
<h2 id="实践过程">实践过程</h2>
<h3 id="接线">接线</h3>
<ol>
<li><em>电机</em> 和 <em>驱动板</em>接线, 这里直接使用附赠的排线连接.</li>
<li><em>驱动板</em> 和 <em>Stm主板</em> 接线 ( 可以按照自己喜欢的布局连接, 也可以参考驱动板厂家给出的示例.</li>
<li><em>显示屏</em> 和 <em>Stm主板</em> 接线 (TX,RX对接就完了), 这里电池给显示屏供电, 所以直接接到了驱动板引出的5v和GND.</li>
<li><em>Pwlink2lite下载器</em> 和 <em>Stm主板</em> 接线( 这里要单独接一个TX-&gt;RX, 用来输出调试信息).</li>
</ol>
<p>这里简单介绍下不同串口的接线意义:</p>
<h4 id="驱动板和stm">驱动板和Stm</h4>
<ol>
<li>驱动板的 E2A和E2B (这里的2代表用的第二个电机,也就是B电机,&ldquo;A&rdquo;,&ldquo;B&quot;代表编码器的A相和B相) 接 Stm 的 两个Pin设定同一个TIM并且将该TIM设定为Combined Mode下的Encoder Mode用来解码从电机获取的实际转速(这里实际是 固定时间的位移 正比于速度, 可以当成转速来用)</li>
<li>驱动板的 ADC 接口 (这里是用来读取电压) 接 Stm 的 Pin 设定为 ADC_IN.(呃呃,这里最后其实没把电压显示出来,所以没用上)</li>
<li>驱动板的 PWMB (这里的B就是代表B电机了) 接 Stm 的 Pin 设定为 TIM 并将对应 TIM 的 对应 CH 设定为PWM GENERATION CHx, 用来输出PWM信号</li>
<li>驱动版的 BIN1,2 接 Stm 的 Pin 设定为 GPIO OUTput, 用来设定电机旋转的模式</li>
</ol>
<p>还有其他的使能,电源接口就不赘述了.可以查看 驱动板的使用说明</p>
<h4 id="触控屏和stm">触控屏和Stm</h4>
<ol>
<li>触控屏使用UART通信, TX,RX 和 Stm 对接(小白注意嗷,TX-&gt;RX对接), Stm上的 两个Pin 设置RX,TX(这里用的USART), 并且要打开对应USART的NVIC (中断)</li>
</ol>
<h4 id="stm和-pwlink2lite-下载器">Stm和 PwLink2lite 下载器</h4>
<ol>
<li>调试下载的直接对应相连, 电压接3v3, GND对接</li>
<li>Pwlink2lite 的 Rx 接到Stm 的 Pin 设置为 USART TX, 用来发送调试信息(后面的代码部分会提到Printf的重定向)</li>
</ol>
<h3 id="stm-cube-mx-配置">Stm Cube MX 配置</h3>
<p>这里的创建工程略过, 小白可以自己看看MX的教学视频</p>
<h4 id="串口设定pin-out">串口设定(Pin OUT)</h4>
<h5 id="这里的串口要对应好自己的实际接线">这里的串口要对应好自己的实际接线.</h5>
<p><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pin_out.png"
width="1112"
height="989"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pin_out_hu06611d6c8d4fc68f059f2a7211a156e7_199638_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pin_out_hu06611d6c8d4fc68f059f2a7211a156e7_199638_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
></p>
<h4 id="串口相应功能设定">串口相应功能设定</h4>
<p>这些功能要对应好你实际的串口设定</p>
<h5 id="tim">TIM</h5>
<p><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/rcc.png"
width="1417"
height="635"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/rcc_hu749d9b4ca982880304e14ae1d218a3b9_148125_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/rcc_hu749d9b4ca982880304e14ae1d218a3b9_148125_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="然后RCC设置给时钟HSE选择CCR源"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
>
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/encoder.png"
width="964"
height="591"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/encoder_hu0cb4eaea236f392224f4bb2d886ce4cd_111946_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/encoder_hu0cb4eaea236f392224f4bb2d886ce4cd_111946_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Encoder (E2A,E2B)"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="391px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pwm.png"
width="914"
height="577"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pwm_hu536268e8857b5e7c97e540165974e99a_104347_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/pwm_hu536268e8857b5e7c97e540165974e99a_104347_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Pwm (PwmB)"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control.png"
width="941"
height="875"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control_hu4db4ca04e1c690adffb3211d5d5e5ab9_165813_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control_hu4db4ca04e1c690adffb3211d5d5e5ab9_165813_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="TIM "
class="gallery-image"
data-flex-grow="107"
data-flex-basis="258px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control1.png"
width="934"
height="709"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control1_hud30bc67d88e4606d86734df99e013dba_183490_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/time_control1_hud30bc67d88e4606d86734df99e013dba_183490_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="续上图配置的周期(用于控制读Encoder并设定Pwm的间隔,这里调成了0.1秒多一次)"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
></p>
<h5 id="adc">ADC</h5>
<p><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/adc.png"
width="910"
height="435"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/adc_hu76805e7ed3647cf5d90adcec01194c89_44184_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/adc_hu76805e7ed3647cf5d90adcec01194c89_44184_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="这里的ADC设置了Single-ended模式"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
></p>
<h5 id="gpio">GPIO</h5>
<p><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/gpio.png"
width="931"
height="1081"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/gpio_hu4620c1d6af36e037585fadb09c11ee09_156730_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/gpio_hu4620c1d6af36e037585fadb09c11ee09_156730_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="这里的GPIO的Bin1和Bin2可以打个标签区分一下, 同时两个都Pull Down(对应的状态是 电机停止)"
class="gallery-image"
data-flex-grow="86"
data-flex-basis="206px"
></p>
<h5 id="usart">USART</h5>
<p><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/screen_usart.png"
width="938"
height="785"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/screen_usart_hu3a00685f918a87810710b7d4b581c1cc_143248_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/screen_usart_hu3a00685f918a87810710b7d4b581c1cc_143248_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="触控屏接到的USART还要打开NVIC全局中断"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="286px"
>
![发送调试信息到Pwlink2lite的Usart把Mode打开成Async就好]<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/printf_usart.png"
width="937"
height="445"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/printf_usart_hufbbd1ce6f6e9d2cf426b2d4c66957dc5_52572_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/printf_usart_hufbbd1ce6f6e9d2cf426b2d4c66957dc5_52572_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="210"
data-flex-basis="505px"
></p>
<h5 id="project-manager">Project Manager</h5>
<p>然后配置一下生成代码的设置, 让它生成单独的c/h文件, 并且生成MDK(Keil)的源代码, 这样后面的VSC + EIDE可以直接以MDK项目格式导入进去,嘎嘎方便.
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/hc.png"
width="2557"
height="1260"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/hc_hub7ae0b88da0fd6eb5b9d150d279a9c1c_307450_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/hc_hub7ae0b88da0fd6eb5b9d150d279a9c1c_307450_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="生成单独c/h文件"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="487px"
>
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/mdk.png"
width="2560"
height="1263"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/mdk_huf2c82dab1e6b106f83a5e1f661bb4c21_350215_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/mdk_huf2c82dab1e6b106f83a5e1f661bb4c21_350215_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="生成MDK项目"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="486px"
></p>
<h3 id="usart-hmi-写刷-触控屏程序">USART HMI 写/刷 触控屏程序</h3>
<p>小白可以先看看这个系列教程了解一下这个 陶晶驰的图形化设计软件的使用方法<br>
<div class="video-wrapper">
<iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;high_quality=1&amp;page=1&bvid=BV16T4y127YE&autoplay=0"
scrolling="no" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
</div>
点击上面可以跳转到完整的系列视频⬆️⬆️⬆️</p>
<p>下面是正文⬇️⬇️⬇️</p>
<p>我设计的简陋的界面
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/home.png"
width="2072"
height="795"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/home_hu4d582b6e9de5983c6fdf2c2f2b1c7da8_247571_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/home_hu4d582b6e9de5983c6fdf2c2f2b1c7da8_247571_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="HOME"
class="gallery-image"
data-flex-grow="260"
data-flex-basis="625px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/about.png"
width="1978"
height="783"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/about_huac7dfe68c132b969493914a8117ee917_356200_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/about_huac7dfe68c132b969493914a8117ee917_356200_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ABOUT"
class="gallery-image"
data-flex-grow="252"
data-flex-basis="606px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func.png"
width="1873"
height="749"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func_hu87881c4c4d9fd19bd5b5842f06b5fc53_263046_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func_hu87881c4c4d9fd19bd5b5842f06b5fc53_263046_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="FUNC"
class="gallery-image"
data-flex-grow="250"
data-flex-basis="600px"
></p>
<p>这里面唯一有用的就是func界面了(其他纯属引流嗷,建议别学我嗷
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func_deatil.png"
width="687"
height="522"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func_deatil_hu57adf9d35597e7a450a8e7d262e59fc3_255222_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/func_deatil_hu57adf9d35597e7a450a8e7d262e59fc3_255222_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Func"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
></p>
<ol>
<li>首先需要两个数字框(绑定数字键盘), 一个用来设定目标速度,一个用来设定目标圈数,并且设定了初始值</li>
<li>然后加个复选框来 选择 正转 or 反转</li>
<li>然后加两个按钮, 一个start 一个 stop, 本质都是用uart发一些数据</li>
</ol>
<p>这里两个按钮需要自己定义一个简单的通信协议, 我这里是这样极其简陋乱写的<br>
<img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/start.png"
width="193"
height="280"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/start_hub1ea8b066bc44846cdeb9988ecd989c4_20676_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/start_hub1ea8b066bc44846cdeb9988ecd989c4_20676_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Start"
class="gallery-image"
data-flex-grow="68"
data-flex-basis="165px"
><img src="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/stop.png"
width="344"
height="294"
srcset="https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/stop_hu2a72a1dc7b1766df73c052fd9822e9e0_24339_480x0_resize_box_3.png 480w, https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/stop_hu2a72a1dc7b1766df73c052fd9822e9e0_24339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Stop"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="280px"
><br>
也就是 [-1,速度的整数,-2,圈数的整数,-3,复选框(正/反转)的整数]</p>
<p>搞定程序设计我们调试试一下效果,没有问题就可以把 屏幕用下载器接到电脑(自己简单对接可以)</p>
<h3 id="vscode--eide">Vscode + EIDE</h3>
<h4 id="环境配置">环境配置</h4>
<p>小白直接看这个教程吧
<div class="video-wrapper">
<iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;high_quality=1&amp;page=1&bvid=BV1nr4y1R7Jb&autoplay=0"
scrolling="no" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
</div></p>
<h4 id="控制代码">控制代码</h4>
<p>EIDE 导入项目后 开始写代码<br>
这里由于程序简单, 我直接全写在main.c了</p>
<p><em>这里注意一定要在 BEGIN 和 END 中间来写自己的代码, 否则CubeMX再次生成代码时, 会把你非用户代码区的代码删掉了.</em><br>
<em>下面的代码中也只有 BEGIN 和 END 中间的代码是开发者自己写的,其他全部由CubeMX自动生成</em></p>
<h5 id="include">include</h5>
<p>这里只用到了一个pid(这个代码分享在最后吧), 一个stdio(使用printf)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN Includes */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pid.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stdio.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* USER CODE END Includes */</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="用uart重定向printf到调试器">用uart重定向printf到调试器</h5>
<p>这个记住就好啦, 网上抄来的方法, 确实不错的方案</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 使用HAL库函数HAL_UART_Transmit将字符ch发送到UART4串口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart4</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回发送的字符，这通常不会有实际的影响，但是它需要返回发送的字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="main函数">main函数</h5>
<ol>
<li>初始化一些参数, 并初始化一个PID计算的结构体</li>
<li>把屏幕控制的USART打开来接受信息, 并且设置每接受六次产生一次中断(因为上面的串口屏是设定的发送6个整数)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN 0 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个全局的PID结构体,用来计算PID的时候传参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个buf用来储存从屏幕的uart收到的消息(发了6个整数)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END 0 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief The application entry point.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @retval int
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 1 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 1 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* MCU Configuration--------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN Init */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END Init */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Configure the system clock */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">SystemClock_Config</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN SysInit */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END SysInit */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Initialize all configured peripherals */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_GPIO_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM3_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_ADC1_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM2_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM4_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_UART4_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_USART1_UART_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 2 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里是一个坑, 详情请看下面的PWM部分的Read_Encoder()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">TIM2</span><span class="o">-&gt;</span><span class="n">CNT</span> <span class="o">=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 把屏幕的UART的接受消息打开,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Receive_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">rev_data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 把PID结构体初始化,这里的P I D参数要看自己选择合适的值, 可以根据实际情况适当调节.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">float</span> <span class="n">Incremental_KP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Incremental_KI</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Incremental_KD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 调用PID初始化函数(这个代码我放在结尾吧, 作者是物院实验室某佬)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// 这里最后两个参数是限定I项的, 具体左右可以看代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">PID_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">Incremental_KP</span><span class="p">,</span> <span class="n">Incremental_KI</span><span class="p">,</span> <span class="n">Incremental_KD</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 2 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN WHILE */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END WHILE */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 3 */</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 3 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="屏幕串口的uart中断">屏幕串口的UART中断</h5>
<p>我们通过重定义中断回调函数来实现对HAL的中断回调的使用<br>
下面的代码 通过 屏幕串口USART中断来实现 不同状态下 激活/关闭 计时器和电机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 这里定义一些变量
</span></span></span><span class="line"><span class="cl"><span class="c1">// 电机转一圈所需的Encoder读数累和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Each_Circle</span> <span class="o">=</span> <span class="mi">1440</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设定的目标速度 Encoder读出的真实速度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设定的目标位置总读数和 实际位置读数和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Target_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Reality_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 给电机的PWM设定的占空比数值(这里需要每次累加,因为使用的是增程式pid)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Set_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Start_TIM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start Encoder tim 开启解码器时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Encoder_Start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">,</span> <span class="n">TIM_CHANNEL_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start Time Control tim 开启定时控制的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Base_Start_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start the pwm tim 开启pwm输出的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_PWM_Start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim3</span><span class="p">,</span> <span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Stop_TIM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 重置各种参数。 防止下次启动时有上次残留的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Target_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reality_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Set_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop Encoder tim 关闭解码器时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Encoder_Stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">,</span> <span class="n">TIM_CHANNEL_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop Time Control tim 关闭定时控制的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Base_Stop_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop the pwm tim 关闭pwm输出的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_PWM_Stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim3</span><span class="p">,</span> <span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个函数用来设定电机 正转/反转/不转/刹车
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">MoTo</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里需要对照你的接线来设定,BIN1和BIN2对应的不同状态状态可以在驱动的说明中找到
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同时也要对应好 屏幕设定的 复选框 发送的0/1对应的正反转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> 1 foreward
</span></span></span><span class="line"><span class="cl"><span class="cm"> 0 reversal
</span></span></span><span class="line"><span class="cl"><span class="cm"> -1 stop
</span></span></span><span class="line"><span class="cl"><span class="cm"> -2 brake
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="o">-</span><span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">HAL_UART_RxCpltCallback</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span> <span class="o">*</span><span class="n">huart</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 这是HAL库提供的UART接收完成回调函数，当UART接收完成时，该函数会被自动调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 判断是哪个UART触发了回调，这里使用了单个UART1，可以根据实际情况进行扩展。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">huart</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">huart1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 清除空闲中断标志位，UART通信中，空闲中断通常用于检测接收结束。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_CLEAR_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">UART_CLEAR_IDLEF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 禁用UART发送中断，以防止在处理接收数据时发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_DISABLE_IT</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="n">UART_IT_TXE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 检查接收到的数据是否符合预期的协议，如果传输中出错了,就直接跳过不执行,根据协议格式解析数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// -1 -2 -3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">rev_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="o">&amp;&amp;</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFE</span> <span class="o">&amp;&amp;</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 从接收到的数据中提取速度、圈数和模式信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">int</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">circle</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 检查速度和圈数是否都不为零，才需要转动。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">circle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 如果目标速度和位置都为零，则说明当前没有进行任何动作，可以开始新的动作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">Target_Velocity</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Target_Position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 设置目标速度和目标位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Target_Position</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">*</span> <span class="n">Each_Circle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 根据模式调用MoTo函数执行相应的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// MoTo 函数定义时要把屏幕传过来的 (0/1) 和 真实转动的对应正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 启动定时器,这样其他的中断才会发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Start_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 如果速度或圈数为零，就说明要停下电机。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 调用MoTo函数执行刹停电机。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 重置各种参数(防止下次启动时有上次残留的值) 并且 停止定时器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Stop_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 重新启用UART发送中断，以便后续可以发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_ENABLE_IT</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="n">UART_IT_TXE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 重新启用UART接收中断，以便继续接收数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Receive_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">rev_data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 清空UART的数据寄存器，以确保不会因为残留数据而触发接收中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_FLUSH_DRREGISTER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 清除UART接收缓冲区非空标志位，以确保下一次接收可以正常触发中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_CLEAR_FLAG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">UART_FLAG_RXNE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="固定时间间隔的-中断控制">固定时间间隔的 中断控制</h5>
<p>之所以要新开一个 tim, 固定时间的读取encoder并设定pwm, 是为了</p>
<ol>
<li>encoder读出的实际可以理解为转动的总距离, 只有时间间隔固定, 我们才能将固定时间的 转动距离差 当作 速度来用</li>
<li>防止过快的设置pwm, 别把电机玩坏了(</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 这里读取encoder有一个坑
</span></span></span><span class="line"><span class="cl"><span class="c1">// 由于这个encoder是一直累加(或减,取决于电机正反转)的, 它累加到最大值(减到0) 就自动重置了
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因此你上一次读的数 不一定比 这次读的数大, 这样一算差值, 就可能出现一个极其大的负值
</span></span></span><span class="line"><span class="cl"><span class="c1">// 为了防止这种情况, 我们就需要把这个 tim 的读数一开始(main里面就设置了)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 就设定到一个 中间数值(0和最大之间), 并且 每次读完之后都把它设定回去
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这样就能保证每次都得到一个 计算正确的 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int16_t</span> <span class="nf">Read_Encoder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int16_t</span> <span class="n">count</span> <span class="o">=</span> <span class="nf">__HAL_TIM_GET_COUNTER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">TIM2</span><span class="o">-&gt;</span><span class="n">CNT</span> <span class="o">=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">count</span> <span class="o">-=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里因为电机 正传反转 有一种情况是累加,一种是累减, 所以有正有负
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// 但是计算pid并设置pwm都是正值, 所以返回绝对值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">count</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 固定时间间隔的 中断控制, 每0.1秒多执行一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">HAL_TIM_PeriodElapsedCallback</span><span class="p">(</span><span class="n">TIM_HandleTypeDef</span> <span class="o">*</span><span class="n">htim</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">htim</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">htim4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 读取实际转速(相当于转速)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="nf">Read_Encoder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 转速累和相当于总距离(实际上转速使用这个总距离做差才算出来的,前面已经解释过了)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Reality_Position</span> <span class="o">+=</span> <span class="n">Reality_Velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 每次先判断是不是已经到了设定的要转的总距离, 如果是, 刹车关定时器重置相关参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">Reality_Position</span> <span class="o">&gt;=</span> <span class="n">Target_Position</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 刹车
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 停止计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Stop_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 用PID算法计算出要设定的pwm值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Set_Velocity</span> <span class="o">+=</span> <span class="nf">PID</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">Target_Velocity</span><span class="p">,</span> <span class="n">Reality_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里串口输出一下调试信息,方便查看
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;target: %d, real: %d, set: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Target_Velocity</span><span class="p">,</span> <span class="n">Reality_Velocity</span><span class="p">,</span> <span class="n">Set_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 设定pwm值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Set_Pwm</span><span class="p">(</span><span class="n">Set_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="相关代码分享">相关代码分享</h2>
<h3 id="pid">pid</h3>
<p>由某物院实验室佬手写</p>
<p>pid.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifndef __PID_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __PID_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_LEN 15
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PID_struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">KP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">KI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">KD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">DATA</span><span class="p">[</span><span class="n">MAX_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">MAX_I</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">is_first</span><span class="p">;</span> <span class="c1">// 解决D的首次误差减去0得到一个不正常的D值问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">int</span> <span class="n">top_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">PID_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">,</span> <span class="kt">float</span> <span class="n">kp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ki</span><span class="p">,</span> <span class="kt">float</span> <span class="n">kd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">PID</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tar</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>pid.c</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file PID
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author zl (2293721550@qq.com)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 一个通用的PID函数，该PID接收返回数据全部为float类型
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 使用时先构造PID_struct类型的结构体，再调用PID_init()函数初始化结构体，最后调用PID()函数得到PID的返回值
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @version 0.1
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @date 2023-08-24
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @copyright Copyright (c) 2023
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pid.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 初始化PID结构体
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pid_struct 想要初始化的PID结构体指针
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param kp P项比例系数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param ki I项比例系数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param kd D项比例系数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param len I积分项长度(不能超过MAX_LEN的设定值)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param max_i I项最大输出量,防止出现积分量过大导致的过冲
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">PID_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">,</span> <span class="kt">float</span> <span class="n">kp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ki</span><span class="p">,</span> <span class="kt">float</span> <span class="n">kd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KP</span> <span class="o">=</span> <span class="n">kp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KI</span> <span class="o">=</span> <span class="n">ki</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KD</span> <span class="o">=</span> <span class="n">kd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">LEN</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">MAX_I</span> <span class="o">=</span> <span class="n">max_i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">is_first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">=</span> <span class="n">MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 求出积分项值
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pid_struct 想要处理的PID结构体指针
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">err_sum</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">)</span> <span class="c1">// 获取I值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">buf</span> <span class="o">+=</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 求出微分项值
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pid_struct 想要处理的PID结构体指针
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">err_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">)</span> <span class="c1">// 获取D值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">change_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">is_first</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">change_speed</span> <span class="o">=</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="n">change_speed</span> <span class="o">=</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">is_first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">change_speed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief PID函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pid_struct 想要处理的PID结构体指针
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param tar 目标值
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param cur 当前值
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return float 返回PID计算后的值
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">PID</span><span class="p">(</span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="o">*</span><span class="n">pid_struct</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tar</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cur</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">err</span> <span class="o">=</span> <span class="n">tar</span> <span class="o">-</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">P</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kt">float</span> <span class="n">D</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span> <span class="c1">// PID数据先进先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">-</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">LEN</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">-</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">-</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">LEN</span> <span class="o">+</span> <span class="n">MAX_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">P</span> <span class="o">=</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">DATA</span><span class="p">[</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span><span class="p">];</span> <span class="c1">// 获取PID三值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">I</span> <span class="o">=</span> <span class="nf">err_sum</span><span class="p">(</span><span class="n">pid_struct</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">D</span> <span class="o">=</span> <span class="nf">err_change</span><span class="p">(</span><span class="n">pid_struct</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 数据头向前移动一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">&gt;=</span> <span class="n">MAX_LEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">top_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KI</span> <span class="o">&gt;</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">MAX_I</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">I</span> <span class="o">=</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">MAX_I</span> <span class="o">/</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span> <span class="c1">// 限制I的累计不可大于MAX_I
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="n">pid</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KP</span> <span class="o">+</span> <span class="n">I</span> <span class="o">*</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KI</span> <span class="o">+</span> <span class="n">D</span> <span class="o">*</span> <span class="n">pid_struct</span><span class="o">-&gt;</span><span class="n">KD</span><span class="p">;</span> <span class="c1">// 计算出PID的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="完整的mainc程序">完整的main.c程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN Header */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> ******************************************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file : main.c
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief : Main program body
</span></span></span><span class="line"><span class="cl"><span class="cm"> ******************************************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @attention
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Copyright (c) 2023 STMicroelectronics.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * All rights reserved.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This software is licensed under terms that can be found in the LICENSE file
</span></span></span><span class="line"><span class="cl"><span class="cm"> * in the root directory of this software component.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * If no LICENSE file comes with this software, it is provided AS-IS.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> ******************************************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END Header */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Includes ------------------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;main.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;adc.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;tim.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;usart.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gpio.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Private includes ----------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN Includes */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pid.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stdio.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* USER CODE END Includes */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private typedef -----------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN PTD */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END PTD */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private define ------------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN PD */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END PD */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private macro -------------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN PM */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END PM */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private variables ---------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN PV */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END PV */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private function prototypes -----------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SystemClock_Config</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN PFP */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END PFP */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Private user code ---------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN 0 */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// redirect `printf`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 使用HAL库函数HAL_UART_Transmit将字符ch发送到UART4串口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart4</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回发送的字符，这通常不会有实际的影响，但是它需要返回发送的字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// uint16_t Get_adc(void)
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// HAL_ADC_Start(&amp;hadc1);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// HAL_ADC_PollForConversion(&amp;hadc1, 2);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// if (HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1), HAL_ADC_STATE_REG_EOC))
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// return HAL_ADC_GetValue(&amp;hadc1);
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1">// else
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">// return Get_adc();
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// uint16_t Get_adc_Average(uint8_t times)
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">// uint32_t sum = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1">// for (uint8_t i = 0; i &lt; times; i++)
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">// sum += Get_adc();
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1">// return sum / times;
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// define pid struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">PID_struct</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// the buf for screen usart
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END 0 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief The application entry point.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @retval int
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 1 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 1 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* MCU Configuration--------------------------------------------------------*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN Init */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END Init */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Configure the system clock */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">SystemClock_Config</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN SysInit */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END SysInit */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Initialize all configured peripherals */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_GPIO_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM3_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_ADC1_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM2_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_TIM4_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_UART4_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="nf">MX_USART1_UART_Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里是一个坑, 详情请看下面的PWM部分的Read_Encoder()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">TIM2</span><span class="o">-&gt;</span><span class="n">CNT</span> <span class="o">=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 把屏幕的UART的接受消息打开,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Receive_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">rev_data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 把PID结构体初始化,这里的P I D参数要看自己选择合适的值, 可以根据实际情况适当调节.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">float</span> <span class="n">Incremental_KP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Incremental_KI</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Incremental_KD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 调用PID初始化函数(这个代码我放在结尾吧, 作者是物院实验室某佬)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// 这里最后两个参数是限定I项的, 具体左右可以看代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">PID_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">Incremental_KP</span><span class="p">,</span> <span class="n">Incremental_KI</span><span class="p">,</span> <span class="n">Incremental_KD</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 2 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN WHILE */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END WHILE */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 3 */</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 3 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief System Clock Configuration
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @retval None
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SystemClock_Config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitTypeDef</span> <span class="n">RCC_OscInitStruct</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitTypeDef</span> <span class="n">RCC_ClkInitStruct</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/** Supply configuration update enable
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_PWREx_ConfigSupply</span><span class="p">(</span><span class="n">PWR_LDO_SUPPLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/** Configure the main internal regulator output voltage
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">__HAL_PWR_VOLTAGESCALING_CONFIG</span><span class="p">(</span><span class="n">PWR_REGULATOR_VOLTAGE_SCALE3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">__HAL_PWR_GET_FLAG</span><span class="p">(</span><span class="n">PWR_FLAG_VOSRDY</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/** Initializes the RCC Oscillators according to the specified parameters
</span></span></span><span class="line"><span class="cl"><span class="cm"> * in the RCC_OscInitTypeDef structure.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">OscillatorType</span> <span class="o">=</span> <span class="n">RCC_OSCILLATORTYPE_HSI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">HSIState</span> <span class="o">=</span> <span class="n">RCC_HSI_DIV1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">HSICalibrationValue</span> <span class="o">=</span> <span class="n">RCC_HSICALIBRATION_DEFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLState</span> <span class="o">=</span> <span class="n">RCC_PLL_ON</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLSource</span> <span class="o">=</span> <span class="n">RCC_PLLSOURCE_HSI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLM</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLN</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLQ</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLRGE</span> <span class="o">=</span> <span class="n">RCC_PLL1VCIRANGE_3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLVCOSEL</span> <span class="o">=</span> <span class="n">RCC_PLL1VCOMEDIUM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLFRACN</span> <span class="o">=</span> <span class="mi">3072</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nf">HAL_RCC_OscConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCC_OscInitStruct</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HAL_OK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nf">Error_Handler</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="cm">/** Initializes the CPU, AHB and APB buses clocks
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">ClockType</span> <span class="o">=</span> <span class="n">RCC_CLOCKTYPE_HCLK</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_SYSCLK</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_PCLK1</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_PCLK2</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_D3PCLK1</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_D1PCLK1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">SYSCLKSource</span> <span class="o">=</span> <span class="n">RCC_SYSCLKSOURCE_PLLCLK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">SYSCLKDivider</span> <span class="o">=</span> <span class="n">RCC_SYSCLK_DIV1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">AHBCLKDivider</span> <span class="o">=</span> <span class="n">RCC_HCLK_DIV1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB3CLKDivider</span> <span class="o">=</span> <span class="n">RCC_APB3_DIV1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB1CLKDivider</span> <span class="o">=</span> <span class="n">RCC_APB1_DIV2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB2CLKDivider</span> <span class="o">=</span> <span class="n">RCC_APB2_DIV2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB4CLKDivider</span> <span class="o">=</span> <span class="n">RCC_APB4_DIV1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nf">HAL_RCC_ClockConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCC_ClkInitStruct</span><span class="p">,</span> <span class="n">FLASH_LATENCY_1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HAL_OK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nf">Error_Handler</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE BEGIN 4 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这里定义一些变量
</span></span></span><span class="line"><span class="cl"><span class="c1">// 电机转一圈所需的Encoder读数累和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Each_Circle</span> <span class="o">=</span> <span class="mi">1440</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设定的目标速度 Encoder读出的真实速度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设定的目标位置总读数和 实际位置读数和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Target_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Reality_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 给电机的PWM设定的占空比数值(这里需要每次累加,因为使用的是增程式pid)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Set_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Start_TIM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start Encoder tim 开启解码器时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Encoder_Start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">,</span> <span class="n">TIM_CHANNEL_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start Time Control tim 开启定时控制的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Base_Start_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Start the pwm tim 开启pwm输出的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_PWM_Start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim3</span><span class="p">,</span> <span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Stop_TIM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 重置各种参数。 防止下次启动时有上次残留的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Target_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reality_Position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Set_Velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop Encoder tim 关闭解码器时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Encoder_Stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">,</span> <span class="n">TIM_CHANNEL_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop Time Control tim 关闭定时控制的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_Base_Stop_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Stop the pwm tim 关闭pwm输出的时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_TIM_PWM_Stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim3</span><span class="p">,</span> <span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个函数用来设定电机 正转/反转/不转/刹车
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">MoTo</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里需要对照你的接线来设定,BIN1和BIN2对应的不同状态状态可以在驱动的说明中找到
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同时也要对应好 屏幕设定的 复选框 发送的0/1对应的正反转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> 1 foreward
</span></span></span><span class="line"><span class="cl"><span class="cm"> 0 reversal
</span></span></span><span class="line"><span class="cl"><span class="cm"> -1 stop
</span></span></span><span class="line"><span class="cl"><span class="cm"> -2 brake
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">case</span> <span class="o">-</span><span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN1_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nf">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="n">BIN2_Pin</span><span class="p">,</span> <span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">HAL_UART_RxCpltCallback</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span> <span class="o">*</span><span class="n">huart</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 这是HAL库提供的UART接收完成回调函数，当UART接收完成时，该函数会被自动调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 判断是哪个UART触发了回调，这里使用了单个UART1，可以根据实际情况进行扩展。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">huart</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">huart1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 清除空闲中断标志位，UART通信中，空闲中断通常用于检测接收结束。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_CLEAR_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">UART_CLEAR_IDLEF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 禁用UART发送中断，以防止在处理接收数据时发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_DISABLE_IT</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="n">UART_IT_TXE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 检查接收到的数据是否符合预期的协议，如果传输中出错了,就直接跳过不执行,根据协议格式解析数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// -1 -2 -3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">rev_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="o">&amp;&amp;</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFE</span> <span class="o">&amp;&amp;</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 从接收到的数据中提取速度、圈数和模式信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">int</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">circle</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">rev_data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 检查速度和圈数是否都不为零，才需要转动。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">circle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 如果目标速度和位置都为零，则说明当前没有进行任何动作，可以开始新的动作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">Target_Velocity</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Target_Position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 设置目标速度和目标位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Target_Velocity</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">Target_Position</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">*</span> <span class="n">Each_Circle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 根据模式调用MoTo函数执行相应的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// MoTo 函数定义时要把屏幕传过来的 (0/1) 和 真实转动的对应正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 启动定时器,这样其他的中断才会发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Start_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 如果速度或圈数为零，就说明要停下电机。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 调用MoTo函数执行刹停电机。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 重置各种参数(防止下次启动时有上次残留的值) 并且 停止定时器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Stop_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 重新启用UART发送中断，以便后续可以发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_ENABLE_IT</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="n">UART_IT_TXE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 重新启用UART接收中断，以便继续接收数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">HAL_UART_Receive_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">rev_data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 清空UART的数据寄存器，以确保不会因为残留数据而触发接收中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_FLUSH_DRREGISTER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 清除UART接收缓冲区非空标志位，以确保下一次接收可以正常触发中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">__HAL_UART_CLEAR_FLAG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">UART_FLAG_RXNE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这里读取encoder有一个坑
</span></span></span><span class="line"><span class="cl"><span class="c1">// 由于这个encoder是一直累加(或减,取决于电机正反转)的, 它累加到最大值(减到0) 就自动重置了
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因此你上一次读的数 不一定比 这次读的数大, 这样一算差值, 就可能出现一个极其大的负值
</span></span></span><span class="line"><span class="cl"><span class="c1">// 为了防止这种情况, 我们就需要把这个 tim 的读数一开始(main里面就设置了)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 就设定到一个 中间数值(0和最大之间), 并且 每次读完之后都把它设定回去
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这样就能保证每次都得到一个 计算正确的 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int16_t</span> <span class="nf">Read_Encoder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">int16_t</span> <span class="n">count</span> <span class="o">=</span> <span class="nf">__HAL_TIM_GET_COUNTER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">TIM2</span><span class="o">-&gt;</span><span class="n">CNT</span> <span class="o">=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">count</span> <span class="o">-=</span> <span class="mh">0x7FFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里因为电机 正传反转 有一种情况是累加,一种是累减, 所以有正有负
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// 但是计算pid并设置pwm都是正值, 所以返回绝对值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">count</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Dead_Voltage</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Set_Pwm</span><span class="p">(</span><span class="kt">int</span> <span class="n">Velocity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nf">__HAL_TIM_SET_COMPARE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim3</span><span class="p">,</span> <span class="n">TIM_CHANNEL_3</span><span class="p">,</span> <span class="n">Velocity</span> <span class="o">+</span> <span class="n">Dead_Voltage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 固定时间间隔的 中断控制, 每0.1秒多执行一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">HAL_TIM_PeriodElapsedCallback</span><span class="p">(</span><span class="n">TIM_HandleTypeDef</span> <span class="o">*</span><span class="n">htim</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">htim</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">htim4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 读取实际转速(相当于转速)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Reality_Velocity</span> <span class="o">=</span> <span class="nf">Read_Encoder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 转速累和相当于总距离(实际上转速使用这个总距离做差才算出来的,前面已经解释过了)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Reality_Position</span> <span class="o">+=</span> <span class="n">Reality_Velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 每次先判断是不是已经到了设定的要转的总距离, 如果是, 刹车关定时器重置相关参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">Reality_Position</span> <span class="o">&gt;=</span> <span class="n">Target_Position</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 刹车
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">MoTo</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 停止计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Stop_TIM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 用PID算法计算出要设定的pwm值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">Set_Velocity</span> <span class="o">+=</span> <span class="nf">PID</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">Target_Velocity</span><span class="p">,</span> <span class="n">Reality_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 这里串口输出一下调试信息,方便查看
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;target: %d, real: %d, set: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Target_Velocity</span><span class="p">,</span> <span class="n">Reality_Velocity</span><span class="p">,</span> <span class="n">Set_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 设定pwm值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">Set_Pwm</span><span class="p">(</span><span class="n">Set_Velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* USER CODE END 4 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief This function is executed in case of error occurrence.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @retval None
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Error_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN Error_Handler_Debug */</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* User can add his own implementation to report the HAL error return state */</span>
</span></span><span class="line"><span class="cl"> <span class="nf">__disable_irq</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END Error_Handler_Debug */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef USE_FULL_ASSERT
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief Reports the name of the source file and the source line number
</span></span></span><span class="line"><span class="cl"><span class="cm"> * where the assert_param error has occurred.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param file: pointer to the source file name
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param line: assert_param error line source number
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @retval None
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">assert_failed</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE BEGIN 6 */</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* User can add his own implementation to report the file name and line number,
</span></span></span><span class="line"><span class="cl"><span class="cm"> ex: printf(&#34;Wrong parameters value: file %s on line %d\r\n&#34;, file, line) */</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/* USER CODE END 6 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="cm">/* USE_FULL_ASSERT */</span><span class="cp">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr />