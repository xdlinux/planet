<html><head></head><body><h1 id="STM32-UART通信"><a href="https://blog.ksfu.top/posts/b619/#STM32-UART%E9%80%9A%E4%BF%A1" class="headerlink" title="STM32 UART通信"></a>STM32 UART通信</h1><p><del>令人感慨，大二上学期不知道这玩意的我，是怎么把广和通项目糊出来的？</del></p><p>写完咯 ~ <del>还没写完</del></p><h2 id="参考链接"><a href="https://blog.ksfu.top/posts/b619/#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5" class="headerlink" title="参考链接"></a>参考链接</h2><p>研究原理啥的还是看看参考的博客的好~</p><blockquote><p>[<a href="https://www.emoe.xyz/bonjour-stm32-uart-communication/">Bonjour STM32] No.7-demo 4.串口通信 - Emoe-Studio</a></p><p><a href="https://www.emoe.xyz/ee_tutorial_04/">电子入门教程[04]-喂?zaima? - Emoe-Studio</a></p><p><a href="https://www.cnblogs.com/menlsh/archive/2013/01/28/2880580.html">串口通信与编程01：串口基础知识 - 依旧淡然 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/ChurF-Lin/p/10793111.html">基于STM32之UART串口通信协议（一）详解 - LLLIN000 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/ChurF-Lin/p/10798193.html">基于STM32之UART串口通信协议（二）发送 - LLLIN000 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/ChurF-Lin/p/10809000.html">基于STM32之UART串口通信协议（三）接收 - LLLIN000 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/ChurF-Lin/p/11139901.html">基于STM32之UART串口通信协议（四）Printf发送 - LLLIN000 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/milton/p/14711577.html">STM32 printf 方法重定向到串口UART - Milton - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/ForeverIT/article/details/82263142">STM32 Uart 实现printf函数_ForeverIT的博客-CSDN博客_stm32 实现printf</a></p></blockquote><h2 id="串口通信"><a href="https://blog.ksfu.top/posts/b619/#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1" class="headerlink" title="串口通信"></a>串口通信</h2><p>串口是串行接口（serial port）的简称，也称为串行通信接口或COM接口。</p><img src="https://s2.ax1x.com/2020/02/11/1TKcqI.jpg" style="zoom: 67%;"/><img src="https://s2.ax1x.com/2020/02/11/1TKyMd.jpg" style="zoom:67%;"/><p>串口通信是指采用串行通信协议（serial communication）在一条信号线上将数据一个比特一个比特地逐位进行传输的通信模式。</p><p>串口按电气标准及协议来划分，包括RS-232-C、RS-422、RS485等。</p><p>在串行通信中，数据在1位宽的 <strong>单条线路</strong> 上进行传输，一个字节的数据要分为8次，由低位到高位按顺序一位一位的进行传送。</p><p>串行通信的数据是逐位传输的，发送方发送的每一位都具有固定的时间间隔，这就要求接收方也要按照发送方同样的时间间隔来接收每一位。不仅如此，接收方还必须能够确定一个信息组的开始和结束。</p><p>常用的两种基本串行通信方式包括同步通信和异步通信。</p><p><strong>然后剩下的可以去参考链接继续了解了~</strong> <span class="diana_yiyanzhen"></span></p><h2 id="UART简介"><a href="https://blog.ksfu.top/posts/b619/#UART%E7%AE%80%E4%BB%8B" class="headerlink" title="UART简介"></a>UART简介</h2><p>嵌入式开发中，UART串口通信协议是我们常用的通信协议（UART、I2C、SPI等）之一，全称叫做通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），是 <strong>异步串口通信协议</strong> 的一种，工作原理是将传输数据的每个字符一位接一位地传输，它能将要传输的资料在串行通信与并行通信之间加以转换，能够灵活地与外部设备进行全双工数据交换。<span class="ava_datou"></span></p><p><strong>USART</strong> 相当于UART的升级版，USART支持同步模式，因此USART 需要同步始终信号USART_CK（如STM32 单片机），通常情况同步信号很少使用，因此一般的单片机UART和USART使用方式是一样的，都使用异步模式。因为USART的使用方法上跟UART基本相同，所以在此就 <strong>以UART</strong> 来讲该通信协议了。</p><h2 id="UART功能说明"><a href="https://blog.ksfu.top/posts/b619/#UART%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E" class="headerlink" title="UART功能说明"></a>UART功能说明</h2><p>接口通过三个引脚从外部连接到其它设备。任何 USART 双向通信均需要 至少两个引脚：接收数据输入引脚 (RX) 和发送数据引脚输出 (TX)：</p><p><strong>两个系统的GND必须连在一起</strong>(因为需要有相同的参考电位)</p><p><strong>RX：</strong>接收数据输入引脚就是串行数据输入引脚。过采样技术可区分有效输入数据和噪声，从而用于恢复数据。<br/><strong>TX：</strong>发送数据输出引脚。如果关闭发送器，该输出引脚模式由其 I/O 端口配置决定。如果使 能了发送器但没有待发送的数据，则 TX 引脚处于高电平。在单线和智能卡模式下，该 I/O 用于发送和接收数据（USART 电平下，随后在 SW_RX 上接收数据）。</p><hr/><p>具体原理留个坑，先大概了解到这，这次主要是通过 <strong>CubeMX</strong> 使用UART进行通信~<span class="diana_bixin"></span></p><hr/><h2 id="波特率"><a href="https://blog.ksfu.top/posts/b619/#%E6%B3%A2%E7%89%B9%E7%8E%87" class="headerlink" title="波特率"></a>波特率</h2><p>波特率的单位是 <strong>Bits/s</strong>，很好理解， <strong>每一位的传输时间</strong> 。这个参数决定了串口传输数据的速度，115200，这是串口常用的波特率里很快的一个速度了，但是计算一下，11.5kbits/s，除以8换算成字节，也就是不到2kBytes/s，每秒传输一千多个字节的数据，就是这样一个速度了——比较老的USB2.0的U盘拷贝文件的速度大概在几个MBytes到十几MBytes每秒之间，对比一下可见串口这玩意确实是一个在速度上十分落后的通信接口了。</p><p>如何计算？比如我们的波特率是9600，那么每一位传输的时间是1/9600 s，意思就是说如果接连不断地发送数据帧，按照11bit长度计算，1秒钟可以发送9600/11=872.7，也就是差不多872个数据帧，也就是872字节。按照ASCII字母来说，872个英文字母/s，够直观了8~</p><h2 id="CubeMX配置"><a href="https://blog.ksfu.top/posts/b619/#CubeMX%E9%85%8D%E7%BD%AE" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h2><p>本次使用 STM32F405RGT6</p><h3 id="配置时钟"><a href="https://blog.ksfu.top/posts/b619/#%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F" class="headerlink" title="配置时钟"></a>配置时钟</h3><p>选择外部晶振，然后时钟拉到最高~</p><p>）用一张之前的图，意思差不多</p><img src="https://blog.ksfu.top/img/posts/mg995/0.webp" style="zoom:80%;"/><p><img src="https://blog.ksfu.top/img/posts/mg995/4.webp" alt="4"/></p><h4 id="设置调试接口"><a href="https://blog.ksfu.top/posts/b619/#%E8%AE%BE%E7%BD%AE%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3" class="headerlink" title="设置调试接口"></a>设置调试接口</h4><p>）照着参考链接来</p><p><img src="https://blog.ksfu.top/img/posts/uart/0.webp"/></p><h3 id="配置串口"><a href="https://blog.ksfu.top/posts/b619/#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3" class="headerlink" title="配置串口"></a>配置串口</h3><p>先启用，选择异步通信；然后波特率保持默认的 115200  就行</p><img src="https://blog.ksfu.top/img/posts/uart/1.webp" alt="1"/><h3 id="选择生成必要的代码"><a href="https://blog.ksfu.top/posts/b619/#%E9%80%89%E6%8B%A9%E7%94%9F%E6%88%90%E5%BF%85%E8%A6%81%E7%9A%84%E4%BB%A3%E7%A0%81" class="headerlink" title="选择生成必要的代码"></a>选择生成必要的代码</h3><p><img src="https://blog.ksfu.top/img/posts/uart/2.webp" alt="2"/></p><blockquote><p>1.Copy all used libraries into the project folder</p><p>将所有使用过的库复制到项目文件夹中。</p><p>不管你用，还是没有用到，都拷贝到你工程目录下。这样一来，你工程下文件就比较多。</p><p>2.Copy only the necessary library files </p><p>只复制必要的库文件。</p><p>这个相比上一个减少了很多文件。比如你没有使用CAN、SPI…等外设，就不会拷贝相关库文件到你工程下。</p><p>3.Add necessary library files as reference in the toolchain project configuration file </p><p>在工具链项目配置文件中添加必要的库文件作为参考。</p><p>这里没有复制HAL库文件，只添加了必要文件（如main.c）。相比上面，没有Drivers相关文件。</p></blockquote><blockquote><p>Generate peripheral initialization as a pair of’.c/.h’ files per peripheral</p><p>每个外设生成独立的’.c/.h’文件</p><p>不勾：所有初始化代码都生成在main.c</p><p>勾选：初始化代码生成在对应的外设文件。 如UART初始化代码生成在uart.c中。</p></blockquote><p>）其他配置啥的可以上网搜搜具体意思</p><h2 id="UART-发送"><a href="https://blog.ksfu.top/posts/b619/#UART-%E5%8F%91%E9%80%81" class="headerlink" title="UART 发送"></a>UART 发送</h2><p>主要使用到的函数为</p><p>在 <code>stm32f4xx_hal_uart.c</code> 中</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">HAL_StatusTypeDef <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>pData<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Size<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> Timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><ul><li>huart  ：选择用来发送的UART串口</li><li>pData  ：指向将要发送的数据的指针</li><li>Size   ：发送数据的大小</li><li>Timeout：超时时间</li></ul></blockquote><h3 id="直接发送"><a href="https://blog.ksfu.top/posts/b619/#%E7%9B%B4%E6%8E%A5%E5%8F%91%E9%80%81" class="headerlink" title="直接发送"></a>直接发送</h3><ol><li><p>定义一个数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//数组内十六进制代表“ABCDE”</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> uTx_Data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0x41</span><span class="token punctuation">,</span> <span class="token number">0x42</span><span class="token punctuation">,</span> <span class="token number">0x43</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">,</span> <span class="token number">0x45</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>调用函数发送</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// UART发送,使用打开的第一个端口，发送定义的数组里的字符</span>    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> uTx_Data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uTx_Data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 延迟1s</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ol><h3 id="自己写发送函数"><a href="https://blog.ksfu.top/posts/b619/#%E8%87%AA%E5%B7%B1%E5%86%99%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0" class="headerlink" title="自己写发送函数"></a>自己写发送函数</h3><blockquote><p>前面的发送方式，不仅要传入句柄参数，还有数组、长度、超时时间参数。</p><p>为了简便发送，我们可以专门写一个字符串发送函数，可以直接传入一个数组即可发送，可以更简便地实现字符串发送。</p><p>优点是，发送数据更简便，能够一次性发送很长的数据数组。</p><p>但缺点就是不能控制发送的长度，会将整个数据数组发出。</p></blockquote><p>具体实现方式可以在参考链接中找到~</p><h3 id="使用-printf-函数发送"><a href="https://blog.ksfu.top/posts/b619/#%E4%BD%BF%E7%94%A8-printf-%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81" class="headerlink" title="使用 printf() 函数发送"></a>使用 printf() 函数发送</h3><p><del>好好好好好好好好好好好好好好好好好好</del></p><p>首先打开 <code>usart.c</code>，然后添加头文件 <code>#include &#34;stdio.h&#34;</code></p><p>再加入</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 1 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__GNUC__</span></span>  <span class="token comment">/* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf     set to &#39;Yes&#39;) calls __io_putchar() */</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUTCHAR_PROTOTYPE</span> <span class="token expression"><span class="token keyword">int</span> <span class="token function">__io_putchar</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUTCHAR_PROTOTYPE</span> <span class="token expression"><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __GNUC__ */</span></span><span class="token comment">/**  * @brief  Retargets the C library printf function to the USART.  * @param  None  * @retval None  */</span>PUTCHAR_PROTOTYPE<span class="token punctuation">{</span>  <span class="token comment">/* Place your implementation of fputc here */</span>  <span class="token comment">/* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */</span>  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ch<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* USER CODE END 1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后再到 <code>main.c</code> 中添加头文件 <code>#include &#34;stdio.h&#34;</code></p><p>然后就能愉快的用 <code>printf()</code> 了~</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&#34;Hello World!\n\r&#34;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="具体效果"><a href="https://blog.ksfu.top/posts/b619/#%E5%85%B7%E4%BD%93%E6%95%88%E6%9E%9C" class="headerlink" title="具体效果"></a>具体效果</h3><p>）用这个板子是因为上面已经有 <code>CH340</code> 这个芯片了，电脑上装好驱动可以直接用~</p><p>如果莫得的话，买一个 <code>USB 转 TTL 模块</code> 就行，几块钱~</p><p>主要代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 数组内十六进制代表 ABCDE</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> uTx_Data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0x41</span><span class="token punctuation">,</span> <span class="token number">0x42</span><span class="token punctuation">,</span> <span class="token number">0x43</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">,</span> <span class="token number">0x45</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 直接发送</span>  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> uTx_Data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uTx_Data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 printf 发送</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&#34;Hello World!\n\r&#34;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后连上，打开串口助手，打开串口</p><p><img src="https://blog.ksfu.top/img/posts/uart/3.gif" alt="3"/></p><h2 id="UART-接收"><a href="https://blog.ksfu.top/posts/b619/#UART-%E6%8E%A5%E6%94%B6" class="headerlink" title="UART 接收"></a>UART 接收</h2><p><del>）等我学完</del> <span class="ava_datou"></span></p><p>在之前文件的基础上，打开串口中断</p><img src="https://blog.ksfu.top/img/posts/uart/4.webp" alt="4" style="zoom:50%;"/><p>如果开启了其他中断，要顺便设置一下中断优先级，如果没有默认即可</p><img src="https://blog.ksfu.top/img/posts/uart/5.webp" alt="5" style="zoom:67%;"/><p>生成代码。</p><h3 id="函数说明"><a href="https://blog.ksfu.top/posts/b619/#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E" class="headerlink" title="函数说明"></a>函数说明</h3><ol><li><p>中断处理函数 <code>void USART1_IRQHandler(void)</code> ，在 <code>stm32f4xx_it.c</code> 中；</p></li><li><p>HAL库函数 <code>HAL_UART_Transmit</code> ，用来发送数据；</p></li><li><p>HAL库函数 <code>HAL_UART_Receive</code> ，用来接收函数</p><p>该函数能够通过huart串口接收Size位pData数据。</p><blockquote><p><strong>参数说明：</strong></p><ul><li><p><code>huart</code>  ：选择用来接收的UART串口</p></li><li><p><code>pData</code>   ：指向将要存放数据的指针</p></li><li><p><code>Size</code>   ：接收数据的大小</p></li><li><p><code>Timeout</code> ：超时时间</p></li></ul></blockquote></li></ol><h3 id="接收方式"><a href="https://blog.ksfu.top/posts/b619/#%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F" class="headerlink" title="接收方式"></a>接收方式</h3><p>接收方式大概有三种，大致是</p><ol><li><p>直接接收</p><p>这种方式为在 <code>while</code> 循环中不断判断是否接收成功，<strong>会严重占用程序的进程</strong> ，且接收较长的数据时，会发生接收错误。</p></li><li><p>中断接收，接收一位发送一位</p><p>使用中断可以很大程度的避免不必要的资源浪费。</p><blockquote><p>在没有什么特别事件的时候，单片机会按照原本的程序运行着，等到有数据从UART串口发送过来时，会马上进入UART串口的中断处理函数中，完成相应的中断处理操作，完成后会退出中断函数，并继续原本在进行的程序，这样就不会占用单片机程序太多的进程了。</p><p><strong>但仍会发生前面直接接收方式的接收异常状况</strong> ，主要原因是，在中断处理函数中，我们在接收了数据后并紧接着作出发送的操作，这会出现一个状况，还没来得及将上一次接收到的数据发送出去，就进入下一次接收的中断，然而导致失去了一些数据了。</p></blockquote></li><li><p>中断接收，全部接收完后再发送</p><p>这个方式以一定的资源换取了一定程度数据的完整。</p><blockquote><p>这种接收方式，是在方式2的基础上稍作改进的，较于前两种接收方式，是更好的一种接收方式，不会给原本的程序进程造成太大影响。还可以先接收全部数据（提示：通过定义一个较大的数组来存储），再将数据进行处理，这样能确保接收数据的完整性，并能将数据进行有效的处理、分析。</p></blockquote></li></ol><p>以上 1， 2 两种方式可以在参考博客中找到实现方法，这里主要关注方法 3</p><h3 id="中断接收，全部接收完后再发送"><a href="https://blog.ksfu.top/posts/b619/#%E4%B8%AD%E6%96%AD%E6%8E%A5%E6%94%B6%EF%BC%8C%E5%85%A8%E9%83%A8%E6%8E%A5%E6%94%B6%E5%AE%8C%E5%90%8E%E5%86%8D%E5%8F%91%E9%80%81" class="headerlink" title="中断接收，全部接收完后再发送"></a>中断接收，全部接收完后再发送</h3><h4 id="使能接收中断"><a href="https://blog.ksfu.top/posts/b619/#%E4%BD%BF%E8%83%BD%E6%8E%A5%E6%94%B6%E4%B8%AD%E6%96%AD" class="headerlink" title="使能接收中断"></a><strong>使能接收中断</strong></h4><p>在 <code>HAL_UART_MspInit</code>（在 <code>usart.c</code>中）<strong>使能接收中断</strong> </p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_MspInit</span><span class="token punctuation">(</span>UART_HandleTypeDef<span class="token operator">*</span> uartHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 省略掉的前面的一些配置</span>  <span class="token comment">/* USER CODE BEGIN USART1_MspInit 1 */</span>    <span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>uartHandle<span class="token punctuation">,</span> UART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* USER CODE END USART1_MspInit 1 */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="编写接收中断服务程序"><a href="https://blog.ksfu.top/posts/b619/#%E7%BC%96%E5%86%99%E6%8E%A5%E6%94%B6%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F" class="headerlink" title="编写接收中断服务程序"></a>编写接收中断服务程序</h4><p> <strong><code>USART1_IRQHandler</code></strong> （在 <code>stm32f4xx_it.c</code> 中）</p><p>定义三个静态变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 存储数组</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uRx_Data<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 指向存储数组将要存储数据的位</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span> pRx_Data <span class="token operator">=</span> uRx_Data<span class="token punctuation">;</span><span class="token comment">// 接收数据长度</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>调用HAL库的UART接收函数以及发送函数</p><blockquote><p>2、3步都可以根据自身要求进行改进</p><ul><li>第2步：判断接收结束条件，这个可以根据自己想要接收何种类型的数据而定。本次使用 <code>回车</code> 作为判断条件</li><li>第3步：数据处理，可以在这一步执行自己想要对数据做的一些操作。本次为将接收到的数据重新发送出去。</li></ul></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 1. 接收数据</span><span class="token function">HAL_UART_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> pRx_Data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2. 判断数据结尾</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>pRx_Data <span class="token operator">==</span> <span class="token char">&#39;\n&#39;</span> <span class="token operator">||</span> <span class="token operator">*</span>pRx_Data <span class="token operator">==</span> <span class="token char">&#39;\r&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 3. 将接收成功的数据通过串口发出去</span>  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> uRx_Data<span class="token punctuation">,</span> uLength<span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 4. 初始化指针和数据长度</span>  pRx_Data <span class="token operator">=</span> uRx_Data<span class="token punctuation">;</span> <span class="token comment">//重新指向数组起始位置   uLength  = 0; //长度清零</span><span class="token punctuation">}</span><span class="token comment">// 5. 若未结束，指针往下一位移动，长度自增1</span><span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token operator">++</span>pRx_Data<span class="token punctuation">,</span><span class="token operator">++</span>uLength<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>完整中断服务程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 0 */</span>  <span class="token comment">// 存储数组</span>  <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uRx_Data<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 指向存储数组将要存储数据的位</span>  <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span> pRx_Data <span class="token operator">=</span> uRx_Data<span class="token punctuation">;</span>  <span class="token comment">// 接收数据长度</span>  <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 接收数据</span>  <span class="token function">HAL_UART_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> pRx_Data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断数据结尾</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>pRx_Data <span class="token operator">==</span> <span class="token char">&#39;\n&#39;</span> <span class="token operator">||</span> <span class="token operator">*</span>pRx_Data <span class="token operator">==</span> <span class="token char">&#39;\r&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将接收成功的数据通过串口发出去</span>    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> uRx_Data<span class="token punctuation">,</span> uLength<span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化指针和数据长度</span>    pRx_Data <span class="token operator">=</span> uRx_Data<span class="token punctuation">;</span> <span class="token comment">//重新指向数组起始位置</span>    uLength  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//长度清零</span>  <span class="token punctuation">}</span>  <span class="token comment">// 若未结束，指针往下一位移动，长度自增1</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token operator">++</span>pRx_Data<span class="token punctuation">,</span><span class="token operator">++</span>uLength<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* USER CODE END USART1_IRQn 0 */</span>  <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 1 */</span>  <span class="token comment">/* USER CODE END USART1_IRQn 1 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="查看效果"><a href="https://blog.ksfu.top/posts/b619/#%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C" class="headerlink" title="查看效果"></a>查看效果</h4><p>编译下载，使用串口查看</p><p>默认是不断发送之前的 <code>Hello World ！</code> ，在受到我们发送的数据后，将其再发送，结束后之前运行不受影响。（中断的好处）</p><img src="https://blog.ksfu.top/img/posts/uart/6.gif" alt="6" style="zoom:67%;"/><hr/><p>发送与接收都完成咯，撒花 ~</p><p>）这算是搞明白了当时是如何操纵 <code>Stm32</code> 使用 <code>AT</code> 指令与广和通 <code>L610</code> 通信了 ~</p><p><del>（当时没搞明白，对着例程xjb抄，发送功能糊出来了结果最后没有接收功能……令人感慨。</del></p></body></html>