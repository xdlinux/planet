<html><head></head><body><h1 id="仿星铁渲染Bloom">仿星铁渲染：Bloom<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E4%BB%BF%E6%98%9F%E9%93%81%E6%B8%B2%E6%9F%93Bloom" title="Permanent link">¶</a></h1><!-- more --><p>卡通渲染里 Bloom 还是挺重要的，它能对画面起到润色作用，比简单地后期调高饱和度要好看很多。</p><p><img alt="Bloom 效果图" src="https://note.stalomeow.com/obsidian-vault/attachments/bloom-toon.png"/></p><h2 id="大致流程图">大致流程图<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E5%9B%BE" title="Permanent link">¶</a></h2><pre class="mermaid"><code>flowchart TD Original[原图] -- 预处理 --&gt; Mip0 Mip0 -- 降采样 --&gt; Mip1 Mip1 -- 降采样 --&gt; Mip2 Mip2 -- 降采样 --&gt; Mip3 Mip3 -- 降采样 --&gt; Mip4 Mip4 -- 降采样 --&gt; Mip5 Mip2 -- 高斯模糊 --&gt; Mip2Blur Mip3 -- 高斯模糊 --&gt; Mip3Blur Mip4 -- 高斯模糊 --&gt; Mip4Blur Mip5 -- 高斯模糊 --&gt; Mip5Blur Mip2Blur -- 合并 --&gt; BloomTexture Mip3Blur -- 合并 --&gt; BloomTexture Mip4Blur -- 合并 --&gt; BloomTexture Mip5Blur -- 合并 --&gt; BloomTexture BloomTexture -- 叠加 --&gt; Result[结果] Original -- 叠加 --&gt; Result</code></pre><h2 id="注意-HDR">注意 HDR<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E6%B3%A8%E6%84%8F-HDR" title="Permanent link">¶</a></h2><p>参考 URP Bloom 的 <code>EncodeHDR</code> 和 <code>DecodeHDR</code>。Bloom 可能导致像素值超过 1，部分不支持 B10G11R11 RT 的设备要用 R8G8B8A8 RT 和 RGBM 编码。</p><h2 id="预处理">预处理<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E9%A2%84%E5%A4%84%E7%90%86" title="Permanent link">¶</a></h2><p>预处理就是把图像中较亮的部分提取出来。卡通渲染里一般直接减去一个阈值即可。</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-0-1">1</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_BloomThreshold</span><span class="p">.</span><span class="n">rrr</span><span class="p">);</span></span></code></pre></div></td></tr></tbody></table></div><p>有需要的话，之后还可以给 <code>color</code> 乘上一个强度。</p><h2 id="降采样">降采样<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E9%99%8D%E9%87%87%E6%A0%B7" title="Permanent link">¶</a></h2><p>降采样是为了之后用较小的卷积核模糊更大的范围，就是 Mipmap 的思路。一般用 bilinear 每次长和宽都减少一半。</p><h3 id="避免闪烁">避免闪烁<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E9%81%BF%E5%85%8D%E9%97%AA%E7%83%81" title="Permanent link">¶</a></h3><p>常见的方法是 COD 用的 Karis Average：在第一次降采样时，给颜色乘上一个 <code>weight</code>，避免出现超级亮的像素。</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-1-1">1</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-1-2">2</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-1-3">3</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="kt">float</span><span class="w"> </span><span class="n">luma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">dot</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="kt">float3</span><span class="p">(</span><span class="mf">0.2126</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7152</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0722</span><span class="p">));</span></span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="kt">float</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">luma</span><span class="p">);</span></span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="n">color</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span></span></code></pre></div></td></tr></tbody></table></div><p>这个会降低颜色的饱和度，对卡通渲染来说比较难受，所以我没用。</p><p>其实，闪烁主要的原因是有单独几个超亮像素一会出现一会消失。可以在降采样时，和周围的像素做加权平均，把亮度压下去。这样如果一个像素周围很亮，那么它还是很亮，产生稳定的泛光。如果一个像素周围都是暗的，它的亮度也会被压下去，闪烁就减少了。这个方法对颜色的饱和度没有很大影响，至少肉眼看不出来。</p><p>在 Vertex Shader 里，计算四个 uv 坐标。坐标都取在像素之间，后面 Fragment Shader 里用 bilinear 采样。</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-2-1">1</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-2-2">2</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-2-3">3</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-2-4">4</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-2-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="kt">float4</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_BlitTexture_TexelSize</span><span class="p">;</span></span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="kt">float4</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span></span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3"></a><span class="kt">float4</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span></span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4"></a><span class="n">uv1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texelSize</span><span class="p">.</span><span class="n">xyxy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xyxy</span><span class="p">;</span></span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5"></a><span class="n">uv2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texelSize</span><span class="p">.</span><span class="n">xyxy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xyxy</span><span class="p">;</span></span></code></pre></div></td></tr></tbody></table></div><p>在 Fragment Shader 里，采样，然后计算平均值。</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-3-1">1</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-3-2">2</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-3-3">3</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-3-4">4</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-3-5">5</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="kt">half3</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv1</span><span class="p">.</span><span class="n">xy</span><span class="p">));</span></span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="kt">half3</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv1</span><span class="p">.</span><span class="n">zw</span><span class="p">));</span></span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3"></a><span class="kt">half3</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv2</span><span class="p">.</span><span class="n">xy</span><span class="p">));</span></span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4"></a><span class="kt">half3</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv2</span><span class="p">.</span><span class="n">zw</span><span class="p">));</span></span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5"></a><span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="mf">0.25</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c4</span><span class="p">));</span></span></code></pre></div></td></tr></tbody></table></div><h2 id="高斯模糊">高斯模糊<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A" title="Permanent link">¶</a></h2><p>设 <span class="arithmatex">\(G(x,y)\)</span> 是二维<a href="https://note.stalomeow.com/ecde-afda-cebi/">正态分布</a>的概率密度函数，<span class="arithmatex">\(f(x,y)\)</span> 是坐标为 <span class="arithmatex">\((x,y)\)</span> 处像素的值，<span class="arithmatex">\(h(x,y)\)</span> 是该处模糊后的值。做一个半径为 <span class="arithmatex">\(r\)</span> 的高斯模糊，即</p><div class="arithmatex">\[h(x,y)=\displaystyle\sum\limits_{i=-r}^{r}\displaystyle\sum\limits_{j=-r}^{r}f(x+i,y+j)G(i,j)\]</div><p>假设图像的长和宽分别为 <span class="arithmatex">\(m,n\)</span>，这个采样数是 <span class="arithmatex">\(O(mnr^2)\)</span>，有点多。</p><h3 id="减少采样数">减少采样数<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%87%8F%E5%B0%91%E9%87%87%E6%A0%B7%E6%95%B0" title="Permanent link">¶</a></h3><p>对于 <span class="arithmatex">\(G(x,y)\)</span>，<span class="arithmatex">\(X\)</span> 和 <span class="arithmatex">\(Y\)</span> 是相互独立的，相关系数 <span class="arithmatex">\(\rho=0\)</span>。一般情况下，我们给中间的像素较大的权值（<span class="arithmatex">\(\mu=0\)</span>），并且用对称的卷积核。所以</p><div class="arithmatex">\[G(x,y)=\frac{1}{2\pi \sigma^2} \exp \left (-\dfrac{x^2 + y^2}{2 \sigma^2} \right )\]</div><p>能求出 <span class="arithmatex">\(X\)</span> 和 <span class="arithmatex">\(Y\)</span> 均服从 <span class="arithmatex">\(N(0,\sigma^2)\)</span>，概率密度函数为</p><div class="arithmatex">\[G(x)=\frac{1}{\sqrt{2\pi} \sigma} \exp \left (-\dfrac{x^2}{2 \sigma^2} \right )\]</div><p>且有</p><div class="arithmatex">\[G(x,y)=G(x)G(y)\]</div><p>带入得</p><div class="arithmatex">\[h(x,y)=\displaystyle\sum\limits_{i=-r}^{r} \left (\displaystyle\sum\limits_{j=-r}^{r}f(x+i,y+j)G(j) \right ) G(i)\]</div><p>所以，可以先做纵向模糊</p><div class="arithmatex">\[h_1(x,y)=\displaystyle\sum\limits_{j=-r}^{r} f(x,y+j) G(j)\]</div><p>再做横向模糊</p><div class="arithmatex">\[h(x,y)=\displaystyle\sum\limits_{i=-r}^{r} h_1(x+i,y) G(i)\]</div><p>这样采样数就变成了 <span class="arithmatex">\(O(mnr)\)</span>，需要 2 个 pass。</p><h3 id="快速计算卷积核">快速计算卷积核<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%8D%B7%E7%A7%AF%E6%A0%B8" title="Permanent link">¶</a></h3><p>根据 <a href="https://note.stalomeow.com/aabci-cecj-cecbf/#De-Moivre-Laplace-CLT">De Moivre-Laplace CLT</a>：若 <span class="arithmatex">\(X \sim B(n,p)\)</span>，当 <span class="arithmatex">\(n\)</span> 充分大时，可以近似认为 <span class="arithmatex">\(X \sim N(np, np(1-p))\)</span>。我们需要的是一个对称的卷积核，所以取 <span class="arithmatex">\(p=\dfrac{1}{2}\)</span>。这个其实就是一些文章中提到用杨辉三角近似的原理。</p><p><img alt="杨辉三角" src="https://note.stalomeow.com/obsidian-vault/attachments/pascal-triangle.png"/></p><p>对于第 <span class="arithmatex">\(n\)</span> 行的一组数，它们除以 <span class="arithmatex">\(2^n\)</span> 后近似服从 <span class="arithmatex">\(N(\dfrac{n}{2},\dfrac{n}{4})\)</span>。</p><p>观察上面的图，每行最前面两个和最后面两个数都比较小，在计算时作用不大，可以去掉它们。<sup id="fnref:1"><a class="footnote-ref" href="https://note.stalomeow.com/blog/posts/toon-bloom/#fn:1">1</a></sup> 如果要一个长度为 <span class="arithmatex">\(n\)</span> 的卷积核，则选择第 <span class="arithmatex">\(n+3\)</span> 行的中间 <span class="arithmatex">\(n\)</span> 个数存进数组，有</p><div class="arithmatex">\[G[i]=\dfrac{1}{2^{n+3}-2(4+n)} \binom{n+3}{i+2}\]</div><p>根据组合数的性质 <sup id="fnref:2"><a class="footnote-ref" href="https://note.stalomeow.com/blog/posts/toon-bloom/#fn:2">2</a></sup></p><div class="arithmatex">\[\binom{n}{k+1}=\dfrac{n-k}{k+1}\binom{n}{k}\]</div><p>可以求出递推公式</p><div class="arithmatex">\[G[i]=\dfrac{n-i+2}{i+2} G[i-1]\]</div><p>它的初始值，我给出的是 <span class="arithmatex">\(G[0]\)</span> 前面一个值，不存进数组。</p><div class="arithmatex">\[G[-1]=\dfrac{n+3}{2^{n+3}-2(4+n)}\]</div><p>不放代码了，一个 for 循环就行了。还能根据卷积核的对称性优化一下，只需要算一半的数字就行。</p><h3 id="Shader-代码">Shader 代码<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#Shader-%E4%BB%A3%E7%A0%81" title="Permanent link">¶</a></h3><p>需要 C# 代码传入的值：</p><ul><li><code>_BloomKernelSize</code>：卷积核的长度。</li><li><code>_BloomKernel</code>：卷积核数组。</li></ul><p>Shader 里用一个 for 循环采样周围像素。</p><ul><li>卷积核长度为偶数时，为了给中心的像素足够的权重，就都采样在两个像素之间了，<code>i - halfKernelSize</code> 为 <span class="arithmatex">\(-1.5,-0.5,0.5,1.5\)</span> 这样的值。</li><li>卷积核长度为奇数时，<code>i - halfKernelSize</code> 为 <span class="arithmatex">\(-1,0,1\)</span> 这样的值。</li></ul><p>纵向模糊：</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-1"> 1</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-2"> 2</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-3"> 3</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-4"> 4</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-5"> 5</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-6"> 6</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-7"> 7</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-8"> 8</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-9"> 9</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-10">10</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-11">11</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-4-12">12</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="kt">float</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_BlitTexture_TexelSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span></span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="kt">float</span><span class="w"> </span><span class="n">halfKernelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_BloomKernelSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span></span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3"></a><span class="kt">float2</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnityStereoTransformScreenSpaceTex</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span></span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4"></a></span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5"></a><span class="kt">half3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span></span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_BloomKernelSize</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span></span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7"></a><span class="p">{</span></span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8"></a><span class="w"> </span><span class="kt">float2</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">halfKernelSize</span><span class="p">));</span></span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9"></a><span class="w"> </span><span class="kt">half3</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">));</span></span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10"></a><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_BloomKernel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11"></a><span class="p">}</span></span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12"></a><span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="n">color</span><span class="p">);</span></span></code></pre></div></td></tr></tbody></table></div><p>横向模糊类似。</p><p>要把多级 mip 都纵向横向模糊一遍。</p><h3 id="卷积核长度选择">卷积核长度选择<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%8D%B7%E7%A7%AF%E6%A0%B8%E9%95%BF%E5%BA%A6%E9%80%89%E6%8B%A9" title="Permanent link">¶</a></h3><p>根据<a href="https://note.stalomeow.com/ecde-afda-cebi/#3-sigma-%E8%A7%84%E5%88%99">正态分布 &gt; 3 sigma 规则</a>，大致推测出高斯模糊的模糊范围和 <span class="arithmatex">\(\sigma\)</span> 正相关。因为长度为 <span class="arithmatex">\(n\)</span> 的卷积核取的是杨辉三角的第 <span class="arithmatex">\(n+3\)</span> 行，所以</p><div class="arithmatex">\[\sigma \approx \dfrac{\sqrt{n+3}}{2}\]</div><p>因此，模糊的范围和卷积核的长度正相关。</p><p>mip 的分辨率越小，模糊的范围（卷积核的长度）就应该越大，否则可能出现很多方块图样。</p><h3 id="处理多分辨率">处理多分辨率<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%A4%84%E7%90%86%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87" title="Permanent link">¶</a></h3><p>同样的图案在不同分辨率下占有的像素数量不同。在卷积核大小不变的前提下，去模糊本文最上面花火的脸，低分辨率下能采样到脸外面的像素，但是高分辨率下就不一定能采样到了。所以多分辨率下模糊的结果可能不一致，最后泛光效果也不一样。具体来说，分辨率越高，向外泛出的光就越少。</p><p>我目前也没找到什么很好的解决方案，就强行把最后几个需要模糊的 mip 的分辨率都定死了。</p><p>一般游戏都是 16:9、16:10 这样的分辨率。取个比例差不多的较小的分辨率，比如 310x174，基本上没太大问题。要是屏幕比例差得太多，降采样时就会出现明显拉伸，Bloom 结果就会出现 artifact。</p><h3 id="图集优化">图集优化<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%9B%BE%E9%9B%86%E4%BC%98%E5%8C%96" title="Permanent link">¶</a></h3><p>因为要对多级 mip 做模糊，会出现很多 RT switch，对性能有影响。可以把纵向模糊的结果都绘制到一张图集上。用 <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetViewport.html"><code>CommandBuffer.SetViewport</code></a> 来限制绘制的区域。</p><p><img alt="图集" src="https://note.stalomeow.com/obsidian-vault/attachments/bloom-atlas.png"/></p><p>然后再做横向模糊，绘制到另一张图集上。</p><h2 id="合并">合并<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%90%88%E5%B9%B6" title="Permanent link">¶</a></h2><p>需要 C# 代码传入的值：</p><ul><li><code>_BloomUVMinMax</code>：图集中每张图的 uv 范围。xy 是 uv 最小值，zw 是 uv 最大值。</li></ul><p>Shader 里直接把图集里所有图都采样一遍，然后叠加。</p><div class="highlight"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-1">1</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-2">2</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-3">3</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-4">4</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-5">5</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-6">6</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-7">7</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-8">8</a></span><span class="normal"><a href="https://note.stalomeow.com/blog/posts/toon-bloom/#__codelineno-5-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1"></a><span class="kt">float2</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnityStereoTransformScreenSpaceTex</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span></span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2"></a></span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3"></a><span class="kt">half3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span></span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4"></a><span class="n">UNITY_UNROLL</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_MIP_DOWN_BLUR_COUNT</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span></span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5"></a><span class="p">{</span></span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6"></a><span class="w"> </span><span class="kt">float2</span><span class="w"> </span><span class="n">atlasUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">lerp</span><span class="p">(</span><span class="n">_BloomUVMinMax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">_BloomUVMinMax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">zw</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span></span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7"></a><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">atlasUV</span><span class="p">));</span></span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8"></a><span class="p">}</span></span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9"></a><span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="n">color</span><span class="p">);</span></span></code></pre></div></td></tr></tbody></table></div><p><img alt="叠加好的图，分辨率和图集里最大的那张一样" src="https://note.stalomeow.com/obsidian-vault/attachments/bloom-final.png"/></p><p>之后把它拿给 UberPost，加到屏幕上即可。</p><h3 id="防漏光">防漏光<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E9%98%B2%E6%BC%8F%E5%85%89" title="Permanent link">¶</a></h3><p>刚才叠加时是用 bilinear 采样的，在某张图边缘采样时可能采样到图集里的另一张图。解决方法是，在图和图之间加几个像素的 padding，一般 1 个像素就差不多了。</p><h2 id="完整代码">完整代码<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" title="Permanent link">¶</a></h2><p><a href="https://github.com/stalomeow/StarRailNPRShader">GitHub: stalomeow/StarRailNPRShader</a></p><h2 id="参考文章">参考文章<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" title="Permanent link">¶</a></h2><ul><li><a href="https://gwb.tencent.com/community/detail/124756">米哈游技术总监首次分享：移动端高品质卡通渲染的实现与优化方案 -腾讯游戏学堂</a></li><li><a href="https://zhuanlan.zhihu.com/p/525500877">高质量泛光（bloom）从理论到实战 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/630726865">高质量泛光Bloom改进以及高斯核采样的优化 - 知乎</a></li></ul><h2 id="进一步阅读">进一步阅读<a class="headerlink" href="https://note.stalomeow.com/blog/posts/toon-bloom/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB" title="Permanent link">¶</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/675125241">复刻 绝区零/原神 的Bloom效果 - 知乎</a>：Bloom 图集的另一种实现。</li><li><a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">Efficient Gaussian blur with linear sampling – RasterGrid</a>：讲了多种优化手段，除了杨辉三角，还有借助 bilinear 减少采样数的方法。</li></ul><div class="footnote"><hr/><ol><li id="fn:1"><p><a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">Efficient Gaussian blur with linear sampling – RasterGrid</a> <a class="footnote-backref" href="https://note.stalomeow.com/blog/posts/toon-bloom/#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p></li><li id="fn:2"><p><a href="https://stackoverflow.com/questions/15580291/how-to-efficiently-calculate-a-row-in-pascals-triangle">algorithm - How to efficiently calculate a row in pascal&#39;s triangle? - Stack Overflow</a> <a class="footnote-backref" href="https://note.stalomeow.com/blog/posts/toon-bloom/#fnref:2" title="Jump back to footnote 2 in the text">↩</a></p></li></ol></div></body></html>