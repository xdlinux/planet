<html><head></head><body><h1><a id="content-目录" href="https://blog.lsy223622.com/archives/56/#content-%E7%9B%AE%E5%BD%95" class="heading-permalink" aria-hidden="true" title="Permalink"></a>目录</h1>
<ul class="table-of-contents">
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E7%9B%AE%E5%BD%95">目录</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B">项目简介</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80">项目地址</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B">开发过程</a>
<ul>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%A7%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%83%B3%E5%88%B0%E5%81%9A%E8%BF%99%E4%B8%AA%E7%9A%84%E5%91%A2">开始是怎么想到做这个的呢？</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%B9%B2%E8%B6%85%E7%BA%A7%E6%B5%81%E6%B0%B4%E8%B4%A6%E7%8E%AF%E8%8A%82">开干！（超级流水账环节！）</a>
</li>
</ul>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E4%BD%BF%E7%94%A8%E6%BC%94%E7%A4%BA">使用演示</a>
</li>
<li>
<a href="https://blog.lsy223622.com/archives/56/#content-%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2">写在后面</a>
</li>
</ul>
<h1><a id="content-写在前面" href="https://blog.lsy223622.com/archives/56/#content-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2" class="heading-permalink" aria-hidden="true" title="Permalink"></a>写在前面</h1>
<ul>
<li>其实是前段时间写的程序了，但是一直没有在博客上记录下来，现在终于想起来了就写一下。</li>
<li>本文主要是记录一下这个程序的开发过程。</li>
<li>
<del>纯纯流水账没啥好看的捏</del>
</li>
</ul>
<h1><a id="content-项目简介" href="https://blog.lsy223622.com/archives/56/#content-%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B" class="heading-permalink" aria-hidden="true" title="Permalink"></a>项目简介</h1>
<p><a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader/tags"><img src="https://img.shields.io/github/v/tag/lsy223622/XDUClassVideoDownloader" alt="GitHub Tag" loading="lazy"/></a>
<a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader/releases/latest"><img src="https://img.shields.io/github/release-date-pre/lsy223622/XDUClassVideoDownloader" alt="GitHub Release Date" loading="lazy"/></a>
<a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader/releases"><img src="https://img.shields.io/github/downloads/lsy223622/XDUClassVideoDownloader/total" alt="GitHub Downloads (all assets, all releases)" loading="lazy"/></a>
<a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader/stargazers"><img src="https://img.shields.io/github/stars/lsy223622/XDUClassVideoDownloader" alt="GitHub Repo stars" loading="lazy"/></a></p>
<ul>
<li>
<p>本项目是一个用于下载西安电子科技大学录直播平台课程视频的工具。</p>
</li>
<li>
<p>只需输入任意一节课的 <code>liveId</code>，即可自动下载 <code>单节课</code> / <code>单集（半节课）</code> / <code>该课程的所有视频</code>。</p>
<blockquote>
<p><code>liveId</code> 是课程直播的唯一标识，可以在课程直播页面的 URL 中找到。如：<code>http://newesxidian.chaoxing.com/live/viewNewCourseLive1?liveId=12345678</code> 中的 <code>12345678</code>。</p>
</blockquote>
</li>
<li>
<p>同时会保存选择下载的范围内所有视频的 m3u8 链接到对应的 <code>csv</code> 表格中，方便使用其他方式下载。</p>
</li>
<li>
<p>下载时会自动检查之前是否下载过同一节课，如果已经下载则会跳过。所以可以在一学期中的多个时候随时下载新增的录播视频。</p>
</li>
<li>
<p>下载的视频按照课程和时间整理，下载多个课程的视频也不会冲突。</p>
</li>
<li>
<p>文件夹和 <code>csv</code> 表格命名规则：年份-课程号-课程名。</p>
</li>
<li>
<p>课程视频命名规则：课程号-课程名-年月日-周次-节号-视频来源。、</p>
</li>
</ul>
<h1><a id="content-项目地址" href="https://blog.lsy223622.com/archives/56/#content-%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80" class="heading-permalink" aria-hidden="true" title="Permalink"></a>项目地址</h1>
<ul>
<li>
<a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader">lsy223622/XDUClassVideoDownloader</a>
</li>
<li>项目介绍、使用方法、源代码和打包程序都在上面链接里，这里就不重复了哦~</li>
</ul>
<h1><a id="content-开发过程" href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B" class="heading-permalink" aria-hidden="true" title="Permalink"></a>开发过程</h1>
<h2><a id="content-开始是怎么想到做这个的呢" href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%A7%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%83%B3%E5%88%B0%E5%81%9A%E8%BF%99%E4%B8%AA%E7%9A%84%E5%91%A2" class="heading-permalink" aria-hidden="true" title="Permalink"></a>开始是怎么想到做这个的呢？</h2>
<ul>
<li>期末复习的时候，发现学校的录直播平台上有很多课程的录播视频，但是没有下载的按钮，只能在线观看。</li>
<li>但是在线观看的时候经常会卡顿，而且有时候需要反复观看，所以想着能不能下载下来看。</li>
<li>开始想到了 IDM 的视频下载功能，但是体验真不算好：
<ul>
<li>首先需要打开每个视频的播放页面，等待漫长的加载时间，IDM 才能检测到视频。</li>
<li>然后要在每个视频的角落里一个一个点用 IDM 下载，下完所有视频得累死。</li>
<li>而且下载的视频文件名也是随机的一串数字，需要手动整理。</li>
</ul>
</li>
<li>碰巧看到群友提到录直播平台有能获取一节课所有视频链接的接口，于是就想着能不能写一个脚本来批量下载视频。</li>
</ul>
<h2><a id="content-开干超级流水账环节" href="https://blog.lsy223622.com/archives/56/#content-%E5%BC%80%E5%B9%B2%E8%B6%85%E7%BA%A7%E6%B5%81%E6%B0%B4%E8%B4%A6%E7%8E%AF%E8%8A%82" class="heading-permalink" aria-hidden="true" title="Permalink"></a>开干！（超级流水账环节！）</h2>
<ul>
<li>
<p>根据群友提供的链接，使用 <code>Curl</code> 尝试了一下，确实能得到所有视频链接。</p>
<ul>
<li>这个链接能使用一节课的 <code>liveId</code> 获取到这门课所有视频的信息，包括课程号、课程名称、教师名称、上课教室、上课时间、<code>liveId</code> 等信息，群友提供的链接参数非常复杂，我筛选测试之后发现只保留以下参数就能工作：
<ul>
<li>接口链接：<code>http://newesxidian.chaoxing.com/live/listSignleCourse</code>（<code>Single</code> 拼成了 <code>Signle</code>，程序员扣大分）</li>
<li>URL 参数：<code>liveId=12345678</code>（随便一节课就行，不一定要第一节课）</li>
<li>User-Agent: <code>Mozilla/5.0</code>（UA 感觉是黑名单制度，<code>curl</code> 不定义 UA 能正常工作，但 Python 的 <code>requests</code> 就不行，所以我就随便填了这个，能用就行）</li>
<li>Cookie: <code>UID=2</code>（非空就行，随便给个数字，这鉴权太草率了吧）</li>
</ul>
</li>
<li>这个链接能使用一节课的 <code>liveId</code> 获取到这节课的录播查看页面链接，返回链接的 URL 参数是一段 URL 编码后的 Json，解码后能得到三个视频的 m3u8 链接，包括 <code>pptVideo</code> <code>teacherTrack</code> <code>studentFull</code>，分别是投影仪画面、教师画面（自动追踪）和教室学生画面（黑板左上角的摄像头对着整个教室拍，但这个视频下载下来大多是破碎的，也没啥用，网页上播放的时候是隐藏的）。同样是筛选清理之后的参数：
<ul>
<li>接口链接：<code>http://newesxidian.chaoxing.com/live/getViewUrlHls</code>
</li>
<li>URL 参数：<code>liveId=12345678&amp;status=2</code>（<code>status=2</code> 好像是需要的，但我忘记为什么了）</li>
<li>User-Agent: <code>Mozilla/5.0</code>（同上）</li>
<li>Cookie: <code>UID=2</code>（同上）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>然后我直接把这一堆请求、返回值、解析处理的逻辑发给 ChatGPT，让它实现获取一门课所有视频的 m3u8 链接和时间等信息并保存到一个 <code>csv</code> 表格里的功能。多亏了 GPT-4o，给我提供了一段非常完美的 Python 代码。</p>
  <details>
  <summary>展开查看 ChatGPT 给出的代码（那时候请求参数还没清理）</summary>
<pre><code class="language-python">import subprocess
import json
import csv
import urllib.parse

def get_initial_data():
    curl_command = [
        &#34;curl&#34;, &#34;http://newesxidian.chaoxing.com/live/listSignleCourse&#34;,
        &#34;--compressed&#34;,
        &#34;-X&#34;, &#34;POST&#34;,
        &#34;-H&#34;, &#34;User-Agent: Mozilla/5.0 (Wayland; Linux x86_64; rv:120.1) Gecko/20100101 Firefox/120.1&#34;,
        &#34;-H&#34;, &#34;Accept: application/json, text/javascript, */*; q=0.01&#34;,
        &#34;-H&#34;, &#34;Accept-Language: en-US,en;q=0.7,ja;q=0.3&#34;,
        &#34;-H&#34;, &#34;Accept-Encoding: gzip, deflate&#34;,
        &#34;-H&#34;, &#34;Content-Type: application/x-www-form-urlencoded; charset=UTF-8&#34;,
        &#34;-H&#34;, &#34;X-Requested-With: XMLHttpRequest&#34;,
        &#34;-H&#34;, &#34;Origin: http://newesxidian.chaoxing.com&#34;,
        &#34;-H&#34;, &#34;DNT: 1&#34;,
        &#34;-H&#34;, &#34;Sec-GPC: 1&#34;,
        &#34;-H&#34;, &#34;Connection: keep-alive&#34;,
        &#34;-H&#34;, &#34;Referer: http://newesxidian.chaoxing.com/live/viewNewCourseLive1?isStudent=1&#34;,
        &#34;-H&#34;, &#34;Cookie: UID=9876&#34;,
        &#34;--data-raw&#34;, &#34;liveId=11740668&#34;
    ]

    result = subprocess.run(curl_command, capture_output=True, text=True)
    return json.loads(result.stdout)

def get_m3u8_links(live_id):
    curl_command = [
        &#34;curl&#34;, f&#34;http://newesxidian.chaoxing.com/live/getViewUrlHls?liveId={live_id}&amp;status=2&amp;jie=&amp;isStudent=&#34;,
        &#34;--compressed&#34;,
        &#34;-H&#34;, &#34;User-Agent: Mozilla/5.0&#34;,
        &#34;-H&#34;, &#34;Accept: */*&#34;,
        &#34;-H&#34;, &#34;Accept-Language: en-US,en;q=0.7,ja;q=0.3&#34;,
        &#34;-H&#34;, &#34;Accept-Encoding: gzip, deflate&#34;,
        &#34;-H&#34;, &#34;X-Requested-With: XMLHttpRequest&#34;,
        &#34;-H&#34;, &#34;DNT: 1&#34;,
        &#34;-H&#34;, &#34;Sec-GPC: 1&#34;,
        &#34;-H&#34;, &#34;Connection: keep-alive&#34;,
        &#34;-H&#34;, &#34;Referer: http://newesxidian.chaoxing.com/live/viewNewCourseLive1?isStudent=1&#34;,
        &#34;-H&#34;, &#34;Cookie: UID=2&#34;
    ]

    result = subprocess.run(curl_command, capture_output=True, text=True)
    response = result.stdout

    url_start = response.find(&#39;info=&#39;)
    if url_start == -1:
        raise ValueError(&#34;info parameter not found in the response&#34;)

    encoded_info = response[url_start + 5:]
    decoded_info = urllib.parse.unquote(encoded_info)
    info_json = json.loads(decoded_info)

    video_paths = info_json.get(&#39;videoPath&#39;, {})
    ppt_video = video_paths.get(&#39;pptVideo&#39;, &#39;&#39;)
    teacher_track = video_paths.get(&#39;teacherTrack&#39;, &#39;&#39;)
    student_full = video_paths.get(&#39;studentFull&#39;, &#39;&#39;)

    return ppt_video, teacher_track, student_full

def main():
    data = get_initial_data()

    rows = []
    for entry in data:
        live_id = entry[&#34;id&#34;]
        month = entry[&#34;startTime&#34;][&#34;month&#34;]
        date = entry[&#34;startTime&#34;][&#34;date&#34;]
        day = entry[&#34;startTime&#34;][&#34;day&#34;]
        jie = entry[&#34;jie&#34;]
        days = entry[&#34;days&#34;]

        ppt_video, teacher_track, student_full = get_m3u8_links(live_id)

        row = [month, date, day, jie, days, ppt_video, teacher_track, student_full]
        rows.append(row)

    with open(&#39;m3u8.csv&#39;, mode=&#39;w&#39;, newline=&#39;&#39;) as file:
        writer = csv.writer(file)
        writer.writerow([&#39;month&#39;, &#39;date&#39;, &#39;day&#39;, &#39;jie&#39;, &#39;days&#39;, &#39;pptVideo&#39;, &#39;teacherTrack&#39;, &#39;studentFull&#39;])
        writer.writerows(rows)

    print(&#34;m3u8.csv 文件已创建并写入数据。&#34;)

if __name__ == &#34;__main__&#34;:
    main()
</code></pre>
  </details>
</li>
<li>
<p>我之前并没有写过 Python 程序，于是按照习惯让 ChatGPT 在 Python 中调用 <code>Curl</code> 命令行。之后经群友提醒换成了 Python 的 <code>requests</code> 库，这样代码更简洁，无需调用外部程序。</p>
  <details>
  <summary>展开查看改用 requests 库的第一段请求代码</summary>
<pre><code class="language-python">def get_initial_data():
url = &#34;http://newesxidian.chaoxing.com/live/listSignleCourse&#34;
headers = {
    &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Wayland; Linux x86_64; rv:120.1) Gecko/20100101 Firefox/120.1&#34;,
    &#34;Accept&#34;: &#34;application/json, text/javascript, */*; q=0.01&#34;,
    &#34;Accept-Language&#34;: &#34;en-US,en;q=0.7,ja;q=0.3&#34;,
    &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
    &#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded; charset=UTF-8&#34;,
    &#34;X-Requested-With&#34;: &#34;XMLHttpRequest&#34;,
    &#34;Origin&#34;: &#34;http://newesxidian.chaoxing.com&#34;,
    &#34;DNT&#34;: &#34;1&#34;,
    &#34;Sec-GPC&#34;: &#34;1&#34;,
    &#34;Connection&#34;: &#34;keep-alive&#34;,
    &#34;Referer&#34;: &#34;http://newesxidian.chaoxing.com/live/viewNewCourseLive1?isStudent=1&#34;,
    &#34;Cookie&#34;: &#34;UID=9876&#34;
}
data = {
    &#34;liveId&#34;: &#34;11740668&#34;
}

response = requests.post(url, headers=headers, data=data)
response.raise_for_status()
return response.json()
</code></pre>
  </details>
</li>
<li>
<p>程序一动不动地在那里默默干活肯定不行，我们也需要知道它有没有死，于是使用 <code>tqdm</code> 加了一个进度条。</p>
  <details>
  <summary>展开查看使用 tqdm 的代码</summary>
<pre><code class="language-python">for entry in tqdm(data, desc=&#34;Processing entries&#34;):
    live_id = entry[&#34;id&#34;]
    month = entry[&#34;startTime&#34;][&#34;month&#34;]
    date = entry[&#34;startTime&#34;][&#34;date&#34;]
    day = entry[&#34;startTime&#34;][&#34;day&#34;]
    jie = entry[&#34;jie&#34;]
    days = entry[&#34;days&#34;]

    ppt_video, teacher_track, student_full = get_m3u8_links(live_id)

    row = [month, date, day, jie, days, ppt_video, teacher_track, student_full]
    rows.append(row)
</code></pre>
  </details>
</li>
<li>
<p>获取到 m3u8 链接之后，就可以让它调用下载程序下载视频了。这里我使用了 <a rel="noopener noreferrer" href="https://github.com/nilaoda/N_m3u8DL-RE">N_m3u8DL-RE</a>，因为 m3u8 是一种索引文件，里面包含了视频的分段链接，<code>N_m3u8DL-RE</code> 可以自动下载并合并这些分段视频。</p>
  <details>
  <summary>展开查看使用 subprocess 调用 N_m3u8DL-RE 的代码</summary>
<pre><code class="language-python">command = f&#39;N_m3u8DL-RE.exe &#34;{url}&#34; --save-dir &#34;m3u8&#34; --save-name &#34;{filename}&#34;&#39;
subprocess.run(command, shell=True, check=True)
</code></pre>
  </details>
</li>
<li>
<p>为了让文件名信息丰富易于整理，按照“courseCodecourseNamex年x月x日第days周星期day第jie节-pptVideo/teacherTrack”的格式命名，星期几转换成更加符合习惯的汉字。</p>
  <details>
  <summary>展开查看文件名命名代码</summary>
<pre><code class="language-python">def day_to_chinese(day):
    days = [&#34;日&#34;, &#34;一&#34;, &#34;二&#34;, &#34;三&#34;, &#34;四&#34;, &#34;五&#34;, &#34;六&#34;]
    return days[day]

for row in tqdm(rows, desc=&#34;Downloading videos&#34;):
    month, date, day, jie, days, ppt_video, teacher_track, student_full = row
    day_chinese = day_to_chinese(day)

    if ppt_video:
        filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-pptVideo&#34;
        download_m3u8(ppt_video, filename)

    if teacher_track:
        filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-teacherTrack&#34;
        download_m3u8(teacher_track, filename)
</code></pre>
  </details>
</li>
<li>
<p>接口提供的信息没有年份，倒是有时间戳。如果是重修的话一门课就会上不止一次，为了可以收藏不同学年的同一节课，改成用时间戳转换得到年月日。</p>
  <details>
  <summary>展开查看时间戳转换代码</summary>
<pre><code class="language-python">start_time_unix = start_time / 1000
start_time_struct = time.gmtime(start_time_unix)
month = start_time_struct.tm_mon
date = start_time_struct.tm_mday
</code></pre>
  </details>
</li>
<li>
<p>判断是否存在已经下载的视频，存在就跳过下载。</p>
  <details>
  <summary>展开查看更新后的代码</summary>
<pre><code class="language-python">for row in tqdm(rows, desc=&#34;Downloading videos&#34;):
    month, date, day, jie, days, ppt_video, teacher_track = row
    day_chinese = day_to_chinese(day)

    if ppt_video:
        filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-pptVideo&#34;
        filepath = os.path.join(save_dir, f&#34;{filename}.ts&#34;)
        if os.path.exists(filepath):
            print(f&#34;{filepath} 已存在，跳过下载。&#34;)
        else:
            download_m3u8(ppt_video, filename, save_dir)

    if teacher_track:
        filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-teacherTrack&#34;
        filepath = os.path.join(save_dir, f&#34;{filename}.ts&#34;)
        if os.path.exists(filepath):
            print(f&#34;{filepath} 已存在，跳过下载。&#34;)
        else:
            download_m3u8(teacher_track, filename, save_dir)
</code></pre>
  </details>
</li>
<li>
<p>感谢群友 <a rel="noopener noreferrer" href="https://github.com/chitao1234">chi(Waylandhater</a> 提出的添加命令行使用方法和单个视频下载模式，并且十分贴心地发了 pull request，直接帮我搞定了。</p>
  <details>
  <summary>展开查看添加命令行使用方法的代码</summary>
<pre><code class="language-python">from argparse import ArgumentParser

def main(liveid_from_cli=None, command=&#39;&#39;):
while True:
    if liveid_from_cli:
        input_live_id = liveid_from_cli
        liveid_from_cli = None
    else:
        input_live_id = input(&#34;请输入 liveId：&#34;)
......

def parse_arguments():
    parser = ArgumentParser(description=&#39;用于下载西安电子科技大学录直播平台课程视频的工具&#39;)
    parser.add_argument(&#39;liveid&#39;, nargs=&#39;?&#39;, default=None, help=&#39;直播ID，不输入则采用交互式方式获取&#39;)
    parser.add_argument(&#39;-c&#39;, &#39;--command&#39;, default=&#39;&#39;, help=&#39;自定义下载命令，使用 {url}, {save_dir}, {filename} 作为替换标记&#39;)

    args = parser.parse_args()
    return args

if __name__ == &#34;__main__&#34;:
    args = parse_arguments()
    main(liveid_from_cli=args.liveid, command=args.command)
</code></pre>
  </details>
  <details>
  <summary>展开查看添加单个视频下载模式的代码</summary>
<pre><code class="language-python">def main(liveid_from_cli=None, command=&#39;&#39;, single=False):
while True:
    if liveid_from_cli:
        input_live_id = liveid_from_cli
......

for entry in tqdm(data, desc=&#34;Processing entries&#34;):
    live_id = entry[&#34;id&#34;]
    if single and str(live_id) != input_live_id:
        continue
......

    parser.add_argument(&#39;-s&#39;, &#39;--single&#39;, default=False, action=&#39;store_true&#39;, help=&#39;仅下载单集视频&#39;)
......

if __name__ == &#34;__main__&#34;:
args = parse_arguments()
main(liveid_from_cli=args.liveid, command=args.command, single=args.single)
</code></pre>
  </details>
</li>
<li>
<p>群友说代码开头要加一行 shebang，我就加了一行 shebang。这 shebang 有啥用呢？我也不知道，但网上一搜说是在 Linux 上运行要用的，指定执行这个代码的程序路径。这行一加，看起来代码没啥变化，结果 Windows 上双击运行不起来了，按说是行注释吧，但是双击之后就是闪退。你们 Linux 真的是（指指点点）。</p>
  <details>
  <summary>展开查看添加的 shebang</summary>
<pre><code class="language-python">#!/usr/bin/env python3
</code></pre>
  </details>
</li>
<li>
<p>那行吧，为了照顾 Linux 用户，这 shebang 就留着了。那 Windows 怎么办？我加了一个 <code>bat</code> 文件，双击这个 <code>bat</code> 文件就能正常运行了。</p>
  <details>
  <summary>展开查看添加的 windows_run.bat 文件</summary>
<pre><code class="language-bat">@echo off
python XDUClassVideoDownloader.py %*
pause
</code></pre>
  </details>
</li>
<li>
<p>非常美丽脚本，这使我的运行环境旋转。我突然觉得每个用户在使用之前都照着 Readme 配一遍运行环境也太麻烦了，而且对小白用户来说也不友好，于是想到了把运行环境打包进去，这样用户只需要下载一个文件就能直接运行了。使用 <code>pyinstaller</code> 打包之后就能得到一个 <code>XDUClassVideoDownloader.exe</code> 文件，不用配环境，双击就能运行了。</p>
  <details>
  <summary>展开查看打包命令</summary>
<pre><code class="language-shell">pip install pyinstaller
python -m venv .venv
.venv\Scripts\activate
pip install requests tqdm
pyinstaller --onefile --add-data &#34;N_m3u8DL-RE.exe;.&#34; --add-data &#34;ffmpeg.exe;.&#34; XDUClassVideoDownloader.py
</code></pre>
  </details>
</li>
<li>
<p>打包用的脚本最后需要添加一行，使它在执行结束之后不会自己关闭窗口，等按回车之后才会关闭。</p>
  <details>
  <summary>展开查看等待输入的代码</summary>
<pre><code class="language-python">input(&#34;按回车退出...&#34;)
</code></pre>
  </details>
</li>
<li>
<p>因为添加了 FFmpeg 这个庞然大物，打包之后的 exe 文件有好几十 MB，这可太大了。但是 <code>N_m3u8DL-RE</code> 需要 FFmpeg，执行的时候会检测 FFmpeg 是否存在，不存在就不能正常用了。我还尝试把 FFmpeg 从 <a rel="noopener noreferrer" href="https://github.com/BtbN/FFmpeg-Builds/releases">BtbN</a> 编译的版本换成了 <a rel="noopener noreferrer" href="https://www.gyan.dev/ffmpeg/builds/">gyan.dev</a> 编译的 essentials 版本，但是打包体积也就稍微小了一点，准确来说是从 58.5 MB 减小到了 43.9 MB，至少是个进步吧。</p>
</li>
<li>
<p>然后我又转念一想，这不对劲。我在 <code>N_m3u8DL-RE</code> 的命令行参数里指定了使用二进制合并模式，也就是把下载的分段 ts 文件直接按照二进制编码拼接起来，理论上没有用到 <code>FFmpeg</code> 重新封装。于是我想出了一个神奇的糊弄方案：我用 c 写了个什么用都没有的程序，编译成 <code>exe</code> 文件，改名成 <code>FFmpeg.exe</code> 放到文件夹里。这样 <code>N_m3u8DL-RE</code> 就能检测到 <code>FFmpeg</code> 了，但是实际上并没有用到 <code>FFmpeg</code>。这个程序的代码如下：</p>
  <details>
  <summary>展开查看什么用都没有的代码</summary>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>没用的代码你也看？</p>
  </details>
</li>
<li>
<p>什么用都没有的 <code>FFmpeg.exe</code> 编译出来是 15 KB，换上去 <code>N_m3u8DL-RE</code> 确实能正常运行。但我还是不满意。然后我突然想到可以用 <a rel="noopener noreferrer" href="https://github.com/upx/upx"><code>UPX</code></a> 压缩 <code>exe</code>。结果是 8 KB。嗯，满意了。替换掉原来的 <code>FFmpeg.exe</code>，打包之后的 <code>exe</code> 从 43.9 MB 减小到了 14.4 MB。</p>
  <details>
  <summary>展开查看使用 UPX 压缩的命令</summary>
<pre><code class="language-shell">upx --ultra-brute ffmpeg.exe
</code></pre>
  </details>
</li>
<li>
<p><code>N_m3u8DL-RE</code> 调用 FFmpeg 的时候如果 FFmpeg 不在 <code>Path</code> 中会找不到。但它也提供了一个命令行参数 <code>--ffmpeg-binary-path &lt;PATH&gt;</code> 来指定 FFmpeg 的路径。</p>
  <details>
  <summary>展开查看添加 FFmpeg 路径参数的代码</summary>
<pre><code class="language-python">def resource_path(relative_path):
    base_path = getattr(sys, &#39;_MEIPASS&#39;, os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)

def download_m3u8(url, filename, save_dir, command=&#39;&#39;):
    n_m3u8dl_re_path = resource_path(&#39;N_m3u8DL-RE.exe&#39;)
    ffmpeg_path = resource_path(&#39;ffmpeg.exe&#39;)

    if not command:
        command = f&#39;./{n_m3u8dl_re_path} &#34;{url}&#34; --save-dir &#34;{save_dir}&#34; --save-name &#34;{filename}&#34; --check-segments-count False --binary-merge True --ffmpeg-binary-path &#34;{ffmpeg_path}&#34;&#39;
    else:
        command = command.format(url=url, filename=filename, save_dir=save_dir, ffmpeg_path=ffmpeg_path)
......
</code></pre>
  </details>
</li>
<li>
<p>这时候群友向我推荐了另一个 m3u8 下载器 <a rel="noopener noreferrer" href="https://github.com/clitic/vsd">vsd</a>。它是用 <code>Rust</code> 写的 <del>（我超，原！）</del> 。它的二进制合并模式不需要 FFmpeg。我试了一下，感觉体验不错，于是换成了这个。它的二进制文件比 <code>N_m3u8DL-RE</code> 大一点，但是我发现它没有经过压缩，于是用 <code>UPX</code> 压缩了一下，体积从 13.3 MB 减小到了 3.5 MB，打包体积 11.9 MB。</p>
  <details>
  <summary>展开查看使用 vsd 下载视频的代码</summary>
<pre><code class="language-python">command = f&#39;vsd-upx.exe save {url} -o {save_dir}\{filename} --retry-count 32 -t 16&#39;
</code></pre>
  </details>
</li>
<li>
<p>换成 <code>vsd</code> 之后，有一个功能也可以实现了，那就是下载视频之后自动合并上下半节课。录直播平台的视频是上下半节课分开的，但这两段视频在时间上是连续的，合并在一起更方便看，也方便整理。于是使用 <code>vsd</code> 的 <code>merge</code> 参数实现了这个功能。</p>
  <details>
  <summary>展开查看合并视频的函数（因为这个功能可以开关所以代码里到处都改了一点点，就不全部放上来了）</summary>
<pre><code class="language-python">def merge_videos(files, output_file):
    if sys.platform.startswith(&#39;win32&#39;):
        command = f&#39;vsd-upx.exe merge -o {output_file} {&#34; &#34;.join(files)}&#39;
    else:
        command = f&#39;./vsd-upx merge -o {output_file} {&#34; &#34;.join(files)}&#39;

    try:
        subprocess.run(command, shell=True, check=True)
        print(f&#34;合并完成：{output_file}&#34;)
        for file in files:
            os.remove(file)
    except subprocess.CalledProcessError:
        print(f&#34;合并 {output_file} 失败：\n{traceback.format_exc()}&#34;)
</code></pre>
  </details>
</li>
<li>
<p>添加合并视频功能涉及到了一大堆逻辑改动。</p>
<ul>
<li>
<p>命名的时候，比如合并前文件名是 <code>xxx第5节xxx</code> 和 <code>xxx第6节xxx</code>，合并后的文件名就叫作 <code>xxx第5-6节xxx</code>，文件名的其他部分保持不变。</p>
</li>
<li>
<p>合并的时候考虑到有些时候数据源会丢失几条视频数据，要正确处理视频链接或者视频文件不存在的错误，如果无法下载上下两个半节课或者其中一个半节课就跳过合并。</p>
</li>
<li>
<p>在判断视频是否存在的逻辑中加入检查合并了的文件，也就是:</p>
<ul>
<li>如果上下半节合并的视频存在就跳过下载上下半节课</li>
<li>如果上下半节没有合并的两个视频都存在就尝试合并</li>
<li>如果只存在其中半节就尝试下载另外半节并且如果下载成功就尝试合并</li>
</ul>
</li>
<li>
<p>合并成功后删除合并前的单个视频文件。</p>
</li>
<li>
<p>这个合并视频的功能作为可选项在交互式操作和命令行使用中都提供，默认合并。</p>
</li>
<li>
<p>选择不合并的命令行参数为 <code>--no-merge</code>。</p>
</li>
<li>
<p>不合并的话上面描述的逻辑都不生效，效果和之前的代码保持相同。</p>
</li>
<li>
<p>在交互模式中，如果选择只下载半节课视频，就不询问是否合并，也不执行合并功能。</p>
<details>
<summary>展开查看修改后的 main 函数，这简直是一大坨，希望逻辑上没出错</summary>
<pre><code class="language-python">def main(liveid=None, command=&#39;&#39;, single=0, merge=True):
    if not liveid:
        liveid = int(user_input_with_check(
            &#34;请输入 liveId：&#34;,
            lambda liveid: liveid.isdigit() and len(liveid) &lt;= 10
        ))

        single = user_input_with_check(
            &#34;是否仅下载单节课视频？输入 y 下载单节课，n 下载这门课所有视频，s 则仅下载单集（半节课）视频，直接回车默认单节课 (Y/n/s):&#34;,
            lambda single: single.lower() in [&#39;&#39;, &#39;y&#39;, &#39;n&#39;, &#39;s&#39;]
        ).lower()
        if single in [&#39;&#39;, &#39;y&#39;]:
            single = 1
        elif single == &#39;s&#39;:
            single = 2
        else:
            single = 0

        if single != 2:
            merge = user_input_with_check(
                &#34;是否自动合并上下半节课视频？输入 y 合并，n 不合并，直接回车默认合并 (Y/n):&#34;,
                lambda merge: merge.lower() in [&#39;&#39;, &#39;y&#39;, &#39;n&#39;]
            ).lower() != &#39;n&#39;
    else:
        if single &gt; 2:
            single = 2

    data = get_initial_data(liveid)

    if not data:
        print(&#34;没有找到数据，请检查 liveId 是否正确。&#34;)
        return

    if single:
        matching_entry = next(
            filter(lambda entry: entry[&#34;id&#34;] == liveid, data))

        if not matching_entry:
            raise ValueError(&#34;No matching entry found for the specified liveId&#34;)

        if single == 1:
            start_time = matching_entry[&#34;startTime&#34;]
            data = list(filter(
                lambda entry: entry[&#34;startTime&#34;][&#34;date&#34;] == start_time[&#34;date&#34;] and
                entry[&#34;startTime&#34;][&#34;month&#34;] == start_time[&#34;month&#34;],
                data))
        else:
            data = [matching_entry]

    first_entry = data[0]
    start_time = first_entry[&#34;startTime&#34;][&#34;time&#34;]
    course_code = first_entry[&#34;courseCode&#34;]
    course_name = first_entry[&#34;courseName&#34;]

    start_time_unix = start_time / 1000
    start_time_struct = time.gmtime(start_time_unix)
    year = start_time_struct.tm_year

    save_dir = f&#34;{year}年{course_code}{course_name}&#34;
    os.makedirs(save_dir, exist_ok=True)

    csv_filename = f&#34;{year}年{course_code}{course_name}.csv&#34;

    rows = []
    for entry in tqdm(data, desc=&#34;获取视频链接&#34;):
        live_id = entry[&#34;id&#34;]
        days = entry[&#34;days&#34;]
        day = entry[&#34;startTime&#34;][&#34;day&#34;]
        jie = entry[&#34;jie&#34;]

        start_time = entry[&#34;startTime&#34;][&#34;time&#34;]
        start_time_unix = start_time / 1000
        start_time_struct = time.gmtime(start_time_unix)
        month = start_time_struct.tm_mon
        date = start_time_struct.tm_mday

        ppt_video, teacher_track = get_m3u8_links(live_id)

        row = [month, date, day, jie, days, ppt_video, teacher_track]
        rows.append(row)

    with open(csv_filename, mode=&#39;w&#39;, newline=&#39;&#39;) as file:
        writer = csv.writer(file)
        writer.writerow([&#39;month&#39;, &#39;date&#39;, &#39;day&#39;, &#39;jie&#39;, &#39;days&#39;, &#39;pptVideo&#39;, &#39;teacherTrack&#39;])
        writer.writerows(rows)

    print(f&#34;{csv_filename} 文件已创建并写入数据。&#34;)

    def process_rows(rows):
        for i in range(0, len(rows), 2):
            row1 = rows[i]
            month1, date1, day1, jie1, days1, ppt_video1, teacher_track1 = row1
            day_chinese1 = day_to_chinese(day1)

            row2 = rows[i + 1] if i + 1 &lt; len(rows) else None
            if row2:
                month2, date2, day2, jie2, days2, ppt_video2, teacher_track2 = row2
                day_chinese2 = day_to_chinese(day2)

            ppt_video_files = []
            if ppt_video1:
                filename1 = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-pptVideo.ts&#34;
                filepath1 = os.path.join(save_dir, filename1)
                if not os.path.exists(filepath1):
                    download_m3u8(ppt_video1, filename1, save_dir, command=command)
                ppt_video_files.append(filepath1)

            if ppt_video2:
                filename2 = f&#34;{course_code}{course_name}{year}年{month2}月{date2}日第{days2}周星期{day_chinese2}第{jie2}节-pptVideo.ts&#34;
                filepath2 = os.path.join(save_dir, filename2)
                if not os.path.exists(filepath2):
                    download_m3u8(ppt_video2, filename2, save_dir, command=command)
                ppt_video_files.append(filepath2)

            if len(ppt_video_files) == 2 and merge:
                ppt_merged_filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}-{jie2}节-pptVideo.ts&#34;
                ppt_merged_filepath = os.path.join(save_dir, ppt_merged_filename)
                merge_videos(ppt_video_files, ppt_merged_filepath)

            teacher_track_files = []
            if teacher_track1:
                filename1 = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-teacherTrack.ts&#34;
                filepath1 = os.path.join(save_dir, filename1)
                if not os.path.exists(filepath1):
                    download_m3u8(teacher_track1, filename1, save_dir, command=command)
                teacher_track_files.append(filepath1)

            if teacher_track2:
                filename2 = f&#34;{course_code}{course_name}{year}年{month2}月{date2}日第{days2}周星期{day_chinese2}第{jie2}节-teacherTrack.ts&#34;
                filepath2 = os.path.join(save_dir, filename2)
                if not os.path.exists(filepath2):
                    download_m3u8(teacher_track2, filename2, save_dir, command=command)
                teacher_track_files.append(filepath2)

            if len(teacher_track_files) == 2 and merge:
                teacher_merged_filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}-{jie2}节-teacherTrack.ts&#34;
                teacher_merged_filepath = os.path.join(save_dir, teacher_merged_filename)
                merge_videos(teacher_track_files, teacher_merged_filepath)

    if single == 1:
        process_rows(rows[:2])
    elif single == 2:
        row = rows[0]
        month, date, day, jie, days, ppt_video, teacher_track = row
        day_chinese = day_to_chinese(day)

        if ppt_video:
            filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-pptVideo.ts&#34;
            filepath = os.path.join(save_dir, filename)
            if not os.path.exists(filepath):
                download_m3u8(ppt_video, filename, save_dir, command=command)

        if teacher_track:
            filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-teacherTrack.ts&#34;
            filepath = os.path.join(save_dir, filename)
            if not os.path.exists(filepath):
                download_m3u8(teacher_track, filename, save_dir, command=command)

    else:
        process_rows(rows)

    print(&#34;所有视频下载和处理完成。&#34;)
</code></pre>
</details>
</li>
</ul>
</li>
<li>
<p>几百行代码好长，我小小的脑子要看不过来了，于是我把代码拆分成了几个文件，分别是 <code>XDUClassVideoDownloader.py</code>、<code>downloader.py</code>、<code>api.py</code>、<code>utils.py</code>。这样代码结构更清晰，也方便维护。</p>
  <details>
  <summary>XDUClassVideoDownloader.py：主程序，用户交互和命令行参数解析</summary>
<pre><code class="language-python">#!/usr/bin/env python3

import os
import csv
import time
from argparse import ArgumentParser
from tqdm import tqdm
import traceback
from utils import day_to_chinese, user_input_with_check, create_directory
from downloader import download_m3u8, merge_videos
from api import get_initial_data, get_m3u8_links

def main(liveid=None, command=&#39;&#39;, single=0, merge=True):
    if liveid and not isinstance(liveid, int):
        liveid = int(liveid)
    elif not liveid:
        liveid = int(user_input_with_check(
            &#34;请输入 liveId：&#34;,
            lambda liveid: liveid.isdigit() and len(liveid) &lt;= 10
        ))

        single = user_input_with_check(
            &#34;是否仅下载单节课视频？输入 y 下载单节课，n 下载这门课所有视频，s 则仅下载单集（半节课）视频，直接回车默认单节课 (Y/n/s):&#34;,
            lambda single: single.lower() in [&#39;&#39;, &#39;y&#39;, &#39;n&#39;, &#39;s&#39;]
        ).lower()
        if single in [&#39;&#39;, &#39;y&#39;]:
            single = 1
        elif single == &#39;s&#39;:
            single = 2
        else:
            single = 0

        if single != 2:
            merge = user_input_with_check(
                &#34;是否自动合并上下半节课视频？输入 y 合并，n 不合并，直接回车默认合并 (Y/n):&#34;,
                lambda merge: merge.lower() in [&#39;&#39;, &#39;y&#39;, &#39;n&#39;]
            ).lower() != &#39;n&#39;
    else:
        if single &gt; 2:
            single = 2

    data = get_initial_data(liveid)

    if not data:
        print(&#34;没有找到数据，请检查 liveId 是否正确。&#34;)
        return

    if single:
        matching_entry = next(
            filter(lambda entry: entry[&#34;id&#34;] == liveid, data))

        if not matching_entry:
            raise ValueError(&#34;No matching entry found for the specified liveId&#34;)

        if single == 1:
            start_time = matching_entry[&#34;startTime&#34;]
            data = list(filter(
                lambda entry: entry[&#34;startTime&#34;][&#34;date&#34;] == start_time[&#34;date&#34;] and
                entry[&#34;startTime&#34;][&#34;month&#34;] == start_time[&#34;month&#34;],
                data))
        else:
            data = [matching_entry]

    first_entry = data[0]
    start_time = first_entry[&#34;startTime&#34;][&#34;time&#34;]
    course_code = first_entry[&#34;courseCode&#34;]
    course_name = first_entry[&#34;courseName&#34;]

    start_time_unix = start_time / 1000
    start_time_struct = time.gmtime(start_time_unix)
    year = start_time_struct.tm_year

    save_dir = f&#34;{year}年{course_code}{course_name}&#34;
    create_directory(save_dir)

    csv_filename = f&#34;{year}年{course_code}{course_name}.csv&#34;

    rows = []
    for entry in tqdm(data, desc=&#34;获取视频链接&#34;):
        live_id = entry[&#34;id&#34;]
        days = entry[&#34;days&#34;]
        day = entry[&#34;startTime&#34;][&#34;day&#34;]
        jie = entry[&#34;jie&#34;]

        start_time = entry[&#34;startTime&#34;][&#34;time&#34;]
        start_time_unix = start_time / 1000
        start_time_struct = time.gmtime(start_time_unix)
        month = start_time_struct.tm_mon
        date = start_time_struct.tm_mday

        ppt_video, teacher_track = get_m3u8_links(live_id)

        row = [month, date, day, jie, days, ppt_video, teacher_track]
        rows.append(row)

    with open(csv_filename, mode=&#39;w&#39;, newline=&#39;&#39;) as file:
        writer = csv.writer(file)
        writer.writerow([&#39;month&#39;, &#39;date&#39;, &#39;day&#39;, &#39;jie&#39;, &#39;days&#39;, &#39;pptVideo&#39;, &#39;teacherTrack&#39;])
        writer.writerows(rows)

    print(f&#34;{csv_filename} 文件已创建并写入数据。&#34;)

    def process_rows(rows):
        for i in range(0, len(rows), 2):
            row1 = rows[i]
            month1, date1, day1, jie1, days1, ppt_video1, teacher_track1 = row1
            day_chinese1 = day_to_chinese(day1)

            row2 = rows[i + 1] if i + 1 &lt; len(rows) else None
            if row2:
                month2, date2, day2, jie2, days2, ppt_video2, teacher_track2 = row2
                day_chinese2 = day_to_chinese(day2)

            ppt_video_files = []
            if ppt_video1:
                filename1 = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-pptVideo.ts&#34;
                filepath1 = os.path.join(save_dir, filename1)
                if not os.path.exists(filepath1):
                    download_m3u8(ppt_video1, filename1, save_dir, command=command)
                ppt_video_files.append(filepath1)

            if ppt_video2:
                filename2 = f&#34;{course_code}{course_name}{year}年{month2}月{date2}日第{days2}周星期{day_chinese2}第{jie2}节-pptVideo.ts&#34;
                filepath2 = os.path.join(save_dir, filename2)
                if not os.path.exists(filepath2):
                    download_m3u8(ppt_video2, filename2, save_dir, command=command)
                ppt_video_files.append(filepath2)

            if len(ppt_video_files) == 2 and merge:
                ppt_merged_filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}-{jie2}节-pptVideo.ts&#34;
                ppt_merged_filepath = os.path.join(save_dir, ppt_merged_filename)
                merge_videos(ppt_video_files, ppt_merged_filepath)

            teacher_track_files = []
            if teacher_track1:
                filename1 = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}节-teacherTrack.ts&#34;
                filepath1 = os.path.join(save_dir, filename1)
                if not os.path.exists(filepath1):
                    download_m3u8(teacher_track1, filename1, save_dir, command=command)
                teacher_track_files.append(filepath1)

            if teacher_track2:
                filename2 = f&#34;{course_code}{course_name}{year}年{month2}月{date2}日第{days2}周星期{day_chinese2}第{jie2}节-teacherTrack.ts&#34;
                filepath2 = os.path.join(save_dir, filename2)
                if not os.path.exists(filepath2):
                    download_m3u8(teacher_track2, filename2, save_dir, command=command)
                teacher_track_files.append(filepath2)

            if len(teacher_track_files) == 2 and merge:
                teacher_merged_filename = f&#34;{course_code}{course_name}{year}年{month1}月{date1}日第{days1}周星期{day_chinese1}第{jie1}-{jie2}节-teacherTrack.ts&#34;
                teacher_merged_filepath = os.path.join(save_dir, teacher_merged_filename)
                merge_videos(teacher_track_files, teacher_merged_filepath)

    if single == 1:
        process_rows(rows[:2])
    elif single == 2:
        row = rows[0]
        month, date, day, jie, days, ppt_video, teacher_track = row
        day_chinese = day_to_chinese(day)

        if ppt_video:
            filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-pptVideo.ts&#34;
            filepath = os.path.join(save_dir, filename)
            if not os.path.exists(filepath):
                download_m3u8(ppt_video, filename, save_dir, command=command)

        if teacher_track:
            filename = f&#34;{course_code}{course_name}{year}年{month}月{date}日第{days}周星期{day_chinese}第{jie}节-teacherTrack.ts&#34;
            filepath = os.path.join(save_dir, filename)
            if not os.path.exists(filepath):
                download_m3u8(teacher_track, filename, save_dir, command=command)

    else:
        process_rows(rows)

    print(&#34;所有视频下载和处理完成。&#34;)

def parse_arguments():
    parser = ArgumentParser(description=&#34;用于下载西安电子科技大学录直播平台课程视频的工具&#34;)
    parser.add_argument(&#39;liveid&#39;, nargs=&#39;?&#39;, default=None, help=&#34;课程的 liveId，不输入则采用交互式方式获取&#34;)
    parser.add_argument(&#39;-c&#39;, &#39;--command&#39;, default=&#39;&#39;, help=&#34;自定义下载命令，使用 {url}, {save_dir}, {filename} 作为替换标记&#34;)
    parser.add_argument(&#39;-s&#39;, &#39;--single&#39;, action=&#39;count&#39;, default=0, help=&#34;仅下载单节课视频（-s：单节课视频，-ss：半节课视频）&#34;)
    parser.add_argument(&#39;--no-merge&#39;, action=&#39;store_false&#39;, help=&#34;不合并上下半节课视频&#34;)

    return parser.parse_args()

if __name__ == &#34;__main__&#34;:
    args = parse_arguments()
    try:
        main(liveid=args.liveid, command=args.command, single=args.single, merge=args.no_merge)
    except Exception as e:
        print(f&#34;发生错误：{e}&#34;)
        print(traceback.format_exc())
</code></pre>
  </details>
  <details>
  <summary>downloader.py：下载视频和合并视频的函数</summary>
<pre><code class="language-python">#!/usr/bin/env python3

import subprocess
import sys
import os
import traceback

def download_m3u8(url, filename, save_dir, command=&#39;&#39;):
    if not command:
        if sys.platform.startswith(&#39;win32&#39;):
            command = f&#39;vsd-upx.exe save {url} -o {save_dir}\{filename} --retry-count 32 -t 16&#39;
        else:
            command = f&#39;./vsd-upx save {url} -o {save_dir}/{filename} --retry-count 32 -t 16&#39;
    else:
        command = command.format(url=url, filename=filename, save_dir=save_dir)

    MAX_ATTEMPTS = 2

    for attempt in range(MAX_ATTEMPTS):
        try:
            subprocess.run(command, shell=True, check=True)
            break
        except subprocess.CalledProcessError:
            print(f&#34;第 {attempt+1} 次下载 {filename} 出错：\n{traceback.format_exc()}\n重试中...&#34;)
            if attempt == MAX_ATTEMPTS - 1:
                print(f&#34;下载 {filename} 失败。&#34;)

def merge_videos(files, output_file):
    if sys.platform.startswith(&#39;win32&#39;):
        command = f&#39;vsd-upx.exe merge -o {output_file} {&#34; &#34;.join(files)}&#39;
    else:
        command = f&#39;./vsd-upx merge -o {output_file} {&#34; &#34;.join(files)}&#39;

    try:
        subprocess.run(command, shell=True, check=True)
        print(f&#34;合并完成：{output_file}&#34;)
        for file in files:
            os.remove(file)
    except subprocess.CalledProcessError:
        print(f&#34;合并 {output_file} 失败：\n{traceback.format_exc()}&#34;)
</code></pre>
  </details>
  <details>
  <summary>api.py：获取课程数据和 m3u8 链接的函数</summary>
<pre><code class="language-python">#!/usr/bin/env python3

import requests
import urllib.parse
import json

def get_initial_data(liveid):
    url = &#34;http://newesxidian.chaoxing.com/live/listSignleCourse&#34;
    headers = {
        &#34;User-Agent&#34;: &#34;Mozilla/5.0&#34;,
        &#34;Cookie&#34;: &#34;UID=2&#34;
    }
    data = {
        &#34;liveId&#34;: liveid
    }

    response = requests.post(url, headers=headers, data=data)
    response.raise_for_status()
    return response.json()

def get_m3u8_links(live_id):
    url = f&#34;http://newesxidian.chaoxing.com/live/getViewUrlHls?liveId={live_id}&amp;status=2&#34;
    headers = {
        &#34;User-Agent&#34;: &#34;Mozilla/5.0&#34;,
        &#34;Cookie&#34;: &#34;UID=2&#34;
    }

    response = requests.get(url, headers=headers)
    response.raise_for_status()
    response_text = response.text

    url_start = response_text.find(&#39;info=&#39;)
    if url_start == -1:
        raise ValueError(&#34;info parameter not found in the response&#34;)

    encoded_info = response_text[url_start + 5:]
    decoded_info = urllib.parse.unquote(encoded_info)
    info_json = json.loads(decoded_info)

    video_paths = info_json.get(&#39;videoPath&#39;, {})
    ppt_video = video_paths.get(&#39;pptVideo&#39;, &#39;&#39;)
    teacher_track = video_paths.get(&#39;teacherTrack&#39;, &#39;&#39;)

    return ppt_video, teacher_track
</code></pre>
  </details>
  <details>
  <summary>utils.py：一些工具函数，包含日期汉字转换、输入数据检查、目录创建</summary>
<pre><code class="language-python">#!/usr/bin/env python3

import os

def day_to_chinese(day):
    days = [&#34;日&#34;, &#34;一&#34;, &#34;二&#34;, &#34;三&#34;, &#34;四&#34;, &#34;五&#34;, &#34;六&#34;]
    return days[day]

def user_input_with_check(prompt, check_func):
    while True:
        user_input = input(prompt)
        if check_func(user_input):
            return user_input
        else:
            print(&#34;输入错误，请重新输入：&#34;)

def create_directory(directory):
    os.makedirs(directory, exist_ok=True)
</code></pre>
  </details>
</li>
<li>
<p>为了方便打包版本同步主分支代码，我新建了一个 <code>windows-pack</code> 分支，时不时 rebase 一下。和主分支区别如下：</p>
<ul>
<li>
<code>XDUClassVideoDownloader.py</code> 末尾添加了等待输入，防止窗口自己关闭。</li>
<li>
<code>downloader.py</code> 中的 <code>download_m3u8</code> 函数使用绝对路径而不是相对路径来调用 <code>vsd-upx.exe</code>。</li>
<li>
<code>utils.py</code> 中增加 <code>resource_path</code> 函数，用于获取二进制文件路径。</li>
</ul>
</li>
</ul>
<h1><a id="content-使用演示" href="https://blog.lsy223622.com/archives/56/#content-%E4%BD%BF%E7%94%A8%E6%BC%94%E7%A4%BA" class="heading-permalink" aria-hidden="true" title="Permalink"></a>使用演示</h1>
<ul>
<li>打开最新 <a rel="noopener noreferrer" href="https://github.com/lsy223622/XDUClassVideoDownloader/releases/latest">Release</a> 页面，下载最新版本的 <code>XDUClassVideoDownloader.exe</code> 文件。</li>
<li>双击运行 <code>XDUClassVideoDownloader.exe</code>，按照提示输入 <code>liveId</code>，选择是否下载单节课视频，选择是否合并上下半节课视频。</li>
<li>等待下载完成，下载的视频在当前目录下的 <code>年份+课程代码+课程名称</code> 文件夹中，下载用到的 m3u8 链接和对应的课程时间信息保存在同名 <code>csv</code> 表格中。</li>
</ul>
<p><img src="https://blog.lsy223622.com/usr/uploads/2024/07/2728612307.png" alt="2024-07-07T14:48:24.png" loading="lazy"/></p>
<h1><a id="content-写在后面" href="https://blog.lsy223622.com/archives/56/#content-%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2" class="heading-permalink" aria-hidden="true" title="Permalink"></a>写在后面</h1>
<ul>
<li>最新的版本是 <code>v1.0.0-beta</code>，感觉基本上功能完善了，没啥需要改的了。</li>
<li>以后要是想到什么新功能再加吧，不过现在这个版本已经够用了。</li>
<li>大家要是有什么问题或者建议可以发 Issue 或者直接 QQ 找我。</li>
<li>我第一次在 GitHub 上有一个这么多 Star 的项目，开心捏。</li>
<li>编了这么多话可真是辛苦我了呢，那就写到这里吧~</li>
</ul>

</body></html>